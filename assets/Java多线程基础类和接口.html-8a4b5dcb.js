import{_ as t,M as p,p as c,q as l,R as n,t as a,N as o,a1 as s}from"./framework-fa6fd9c7.js";const i={},u=s(`<h1 id="java多线程基础类和接口" tabindex="-1"><a class="header-anchor" href="#java多线程基础类和接口" aria-hidden="true">#</a> Java多线程基础类和接口</h1><p>我们了解了多线程的基本概念，那么在 Java 中，是如何表示线程和使用多线程的呢？</p><p>Java 中用 <strong>Thread</strong> 类来表示线程，提供 <strong>Runnable</strong> 接口来实现任务。</p><ul><li>extends Thread，重写 run 方法</li><li>implements Runnable ，实现 run 方法</li></ul><p>多线程的基本使用</p><h2 id="thread-和-runnable" tabindex="-1"><a class="header-anchor" href="#thread-和-runnable" aria-hidden="true">#</a> Thread 和 Runnable</h2><h3 id="创建和启动" tabindex="-1"><a class="header-anchor" href="#创建和启动" aria-hidden="true">#</a> 创建和启动</h3><ul><li>创建 Thread 实例</li></ul><p>我们首先要创建一个 Thread 实例，可以继承 Thread，或者传递一个 Runnable.</p><p>继承的方式</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>public class MyThread extends Thread{
    @Override
    public void run() {
        System.out.println(&quot;I&#39;m new Thread&quot;);
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>传递 Runnable 的方式, 可以使用 lambda 语法</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>     new Thread(()-&gt;{
            System.out.println(&quot;I&#39;m new Thread&quot;);
        })
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>调用 **<code>start</code>**方法</li></ul><p>调用<code>start()</code>方法后，线程才会启动。虚拟机会创建一个线程来运行我们实现的<code>run</code>方法。</p><p>启动</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">new</span> <span class="token class-name">MyThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>或者</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;I&#39;m new Thread&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意不可多次调用 start 方法。多次调用会抛出 IllegalThreadStateException。</p></blockquote><h3 id="thread-类构建方法" tabindex="-1"><a class="header-anchor" href="#thread-类构建方法" aria-hidden="true">#</a> Thread 类构建方法</h3><p>Thread 实现了 Runnable 接口。</p><p>来看 Thread 类的构造方法，内部是调用 init 来初始化。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">//片段1 init 方法</span>
<span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token class-name">ThreadGroup</span> g<span class="token punctuation">,</span> <span class="token class-name">Runnable</span> target<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">,</span>
                      <span class="token keyword">long</span> stackSize<span class="token punctuation">,</span> <span class="token class-name">AccessControlContext</span> acc<span class="token punctuation">,</span>
                      <span class="token keyword">boolean</span> inheritThreadLocals<span class="token punctuation">)</span>

<span class="token comment">//片段2 构造函数</span>
<span class="token keyword">public</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">init</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> <span class="token string">&quot;Thread-&quot;</span> <span class="token operator">+</span> <span class="token function">nextThreadNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 片段3 - 使用在init方法里初始化AccessControlContext类型的私有属性</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>inheritedAccessControlContext <span class="token operator">=</span> 
    acc <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> acc <span class="token operator">:</span> <span class="token class-name">AccessController</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 片段4 - 两个对用于支持ThreadLocal的私有属性</span>
<span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> threadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token class-name">ThreadLocal<span class="token punctuation">.</span>ThreadLocalMap</span> inheritableThreadLocals <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>init</code>方法在片段一，见名知意，补充一下：</p><ul><li>name：线程名，可重复，不指定名称，见片段2</li><li>acc: 初始化私有变量，见片段3</li></ul>`,26),r={href:"https://stackoverflow.com/questions/13516766/restrict-permissions-to-threads-which-execute-third-party-software",target:"_blank",rel:"noopener noreferrer"},d=s(`<ul><li>inheritThreadLocals：可继承的 ThreadLocal。见片段4.</li></ul><p>实际情况下，我们大多直接调用下面两个构造方法</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> target<span class="token punctuation">)</span>
<span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token class-name">Runnable</span> target<span class="token punctuation">,</span> <span class="token class-name">String</span> name<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="thread常用方法" tabindex="-1"><a class="header-anchor" href="#thread常用方法" aria-hidden="true">#</a> Thread常用方法</h3><p>静态方法</p><ul><li>currentThread()：返回当前执行线程对象的引用</li><li>yield(): 当前线程愿意放弃对当前处理器的占用。只是意愿，调用该方法后，有可能会继续运行当前线程。</li><li>sleep(): 当前线程睡眠一段时间</li></ul><p>实例方法</p><ul><li>join(): 当前线程等待 实例线程 die 后再执行</li></ul><p>例如</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>
    public static void main(String[] args) throws InterruptedException {
        Thread thread = new Thread(()-&gt;{
            try {
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
            System.out.println(&quot;Thread Hello&quot;);
        });
        thread.start();
        thread.join();
        System.out.println(&quot;Main Hello&quot;);
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>主线程会等 thread 线程执行完，再输出 &quot;Main Hello&quot;</p><h2 id="callable、future、futuretask" tabindex="-1"><a class="header-anchor" href="#callable、future、futuretask" aria-hidden="true">#</a> Callable、Future、FutureTask</h2><p>通常，我们使用 Runnable 和 Thread 来创建新的线程。但是有一个问题，就是 run 方法没有返回值。</p><p>JDK 提供了 <code>Callable</code> 和 <code>Future</code> 接口来解决这个问题，也就是所谓的<strong>异步</strong>模型。</p><h3 id="callable-接口" tabindex="-1"><a class="header-anchor" href="#callable-接口" aria-hidden="true">#</a> Callable 接口</h3><p>Callable 与 Runnable 类似，都是只有一个抽象方法的 lambda 接口。不同的是 Callable 接口有返回值，而且支持泛型。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@FunctionalInterface</span>
<span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token class-name">V</span> <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="callable-的使用" tabindex="-1"><a class="header-anchor" href="#callable-的使用" aria-hidden="true">#</a> Callable 的使用</h3><p>Callable 一般配合线程池工具 ExecutorService 使用。</p><p>ExecutorService 提交一个 Callable ，返回一个 Future，结果可以通过 Future 的 get 方法得到。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> callable <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">&quot;hello,callable&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> s <span class="token operator">=</span> future<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>hello,callable
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="future-接口" tabindex="-1"><a class="header-anchor" href="#future-接口" aria-hidden="true">#</a> Future 接口</h3><p>Future 表示了异步计算的结果。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Future</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> <span class="token function">cancel</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> paramBoolean<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> <span class="token function">isCancelled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> <span class="token function">isDone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">;</span>
    <span class="token class-name">V</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">long</span> paramLong<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> paramTimeUnit<span class="token punctuation">)</span>
            <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token punctuation">,</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">TimeoutException</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>常用方法有</p><ul><li>get 获取异步结果</li><li>cancel 尝试取消线程执行，boolean参数表示是否采用中断方式取消线程。</li></ul><p>所以，为了让任务有取消的功能，可以用 Callable 来代替 Runnable。</p><h3 id="futuretask-类" tabindex="-1"><a class="header-anchor" href="#futuretask-类" aria-hidden="true">#</a> FutureTask 类</h3><p>JDK为 Future 接口提供了实现，这个实现类叫做 FutureTask。</p><p>它实现了 Runnable 和 Future 接口。</p><p>创建 FutureTask 的接口。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span><span class="token class-name">Callable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> callable<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>基本用法如下：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">ExecutionException</span><span class="token punctuation">,</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{</span>
        <span class="token class-name">FutureTask</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> futureTask <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FutureTask</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token string">&quot;hello,world&quot;</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">ExecutorService</span> executorService <span class="token operator">=</span> <span class="token class-name">Executors</span><span class="token punctuation">.</span><span class="token function">newCachedThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        executorService<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>futureTask<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> s <span class="token operator">=</span> futureTask<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什么又FutureTask呢？因为 Future 只是一个接口，里面的 cancel 、 get 、 isDone 自己实现都非常复杂。所以JDK 提供了一个 FutureTask 供我们使用。</p><p>submit 提交的调用的是 <code>submit(Runnable task)</code>方法，是没有返回值的。结果要 通过 <code>FutureTask</code> 实例的 <code>get</code>方法来获取。</p><p>提交<code>Callable</code>是调用 <code>submit(Callable&lt;T&gt; task)</code>，返回一个 <code>Future</code>,通过返回的<code>Futrue</code>来取值。</p>`,39);function k(v,m){const e=p("ExternalLinkIcon");return c(),l("div",null,[u,n("blockquote",null,[n("p",null,[a("inheritedAccessControlContext 可以用来限制线程的执行权限。一般我们是不会使用它的，那什么时候会使用到这个变量呢？可以参考这个stackoverflow的问题："),n("a",r,[a("Restrict permissions to threads which execute third party software"),o(e)]),a("；")])]),d])}const h=t(i,[["render",k],["__file","Java多线程基础类和接口.html.vue"]]);export{h as default};
