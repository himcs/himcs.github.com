import{_ as p,M as t,p as r,q as i,R as n,t as s,N as e,a1 as o}from"./framework-fa6fd9c7.js";const l={},c=o('<h1 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h1><h2 id="acid" tabindex="-1"><a class="header-anchor" href="#acid" aria-hidden="true">#</a> ACID</h2><p>事务所提供的安全保证，通常由众所周知的首字母缩略词 ACID 来描述。ACID 代表 <strong>原子性（Atomicity）</strong>，<strong>一致性（Consistency）</strong>，<strong>隔离性（Isolation）</strong> 和 <strong>持久性（Durability）</strong>。</p><blockquote><p>（不符合 ACID 标准的系统有时被称为 BASE，它代表 <strong>基本可用性（Basically Available）</strong>，<strong>软状态（Soft State）</strong> 和 <strong>最终一致性（Eventual consistency）</strong>，这比 ACID 的定义更加模糊，似乎 BASE 的唯一合理的定义是 “不是 ACID”，即它几乎可以代表任何你想要的东西。）</p></blockquote><h3 id="原子性" tabindex="-1"><a class="header-anchor" href="#原子性" aria-hidden="true">#</a> 原子性</h3><p>一般来说，原子是指不能分解成小部分的东西。这个词在计算机的不同领域中意味着相似但又微妙不同的东西。例如，在多线程编程中，如果一个线程执行一个原子操作，这意味着另一个线程无法看到该操作的一半结果。系统只能处于操作之前或操作之后的状态，而不是介于两者之间的状态。</p>',6),d=n("strong",null,"不",-1),u=n("strong",null,"并发（concurrent）",-1),g=n("strong",null,"I",-1),k={href:"http://ddia.vonng.com/#/ch7?id=%e9%9a%94%e7%a6%bb%e6%80%a7",target:"_blank",rel:"noopener noreferrer"},h=n("strong",null,"隔离性",-1),v=o('<p>如果没有原子性，在多处更改进行到一半时发生错误，很难知道哪些更改已经生效，哪些没有生效。该应用程序可以再试一次，但冒着进行两次相同变更的风险，可能会导致数据重复或错误的数据。原子性简化了这个问题：如果事务被 <strong>中止（abort）</strong>，应用程序可以确定它没有改变任何东西，所以可以安全地重试。</p><p>ACID 原子性的定义特征是：<strong>能够在错误时中止事务，丢弃该事务进行的所有写入变更的能力</strong></p><h3 id="一致性" tabindex="-1"><a class="header-anchor" href="#一致性" aria-hidden="true">#</a> 一致性</h3><p>ACID 一致性的概念是，<strong>对数据的一组特定约束必须始终成立</strong>。即 <strong>不变式（invariants）</strong>。例如，在会计系统中，所有账户整体上必须借贷相抵。</p><p>但是，一致性的概念取决于程序对不变式的理解，应用程序负责正确定义它的事务，并保持一致性。</p><p>原子性，隔离性和持久性是数据库的属性，而一致性（在 ACID 意义上）是<strong>应用程序</strong>的属性。</p><h3 id="隔离性" tabindex="-1"><a class="header-anchor" href="#隔离性" aria-hidden="true">#</a> 隔离性</h3><p>ACID 意义上的隔离性意味着，<strong>同时执行的事务是相互隔离的</strong>。</p><p>如果多个数据库客户端访问相同的数据库，可能会遇到 <strong>并发</strong> 问题（<strong>竞争条件</strong>，即 race conditions）。</p><p>如下图是个简单的并发问题</p><p><img src="http://ddia.vonng.com/img/fig7-1.png" alt=""></p><h3 id="持久性" tabindex="-1"><a class="header-anchor" href="#持久性" aria-hidden="true">#</a> 持久性</h3><p>数据库系统的目的是，提供一个安全的地方存储数据，而不用担心丢失。<strong>持久性</strong> 是一个承诺，即一旦事务成功完成，即使发生硬件故障或数据库崩溃，写入的任何数据也不会丢失。</p><blockquote><p><strong>完美的持久性是不存在的</strong> ：如果所有硬盘和所有备份同时被销毁，那显然没有任何数据库能救得了你。</p></blockquote><h2 id="弱隔离级别" tabindex="-1"><a class="header-anchor" href="#弱隔离级别" aria-hidden="true">#</a> 弱隔离级别</h2><p>如果两个事务不触及相同的数据，他们可以安全<strong>并行（parallel）</strong> 运行。当一个事务读取由另一个事务同时修改的数据，或两个事务试图修改相同的数据时，并发问题（竞争条件）才会出现。</p><p>并发 BUG 很难通过测试找到，因为这样的错误只有在特殊时序下才会触发。这样的时序问题可能非常少发生，通常很难重现。</p><p>出于这个原因，数据库一直试图通过提供 <strong>事务隔离（transaction isolation）</strong> 来隐藏应用程序开发者的并发问题。从理论上讲，隔离可以通过假装没有并发发生，让你的生活更加轻松：<strong>可串行的（serializable）</strong> 隔离等级意味着数据库保证事务的效果如同串行运行（即一次一个，没有任何并发）。</p><p>实际上，<strong>串行</strong>会有<strong>性能</strong>损失，所以许多系统不会使用这种隔离界别，因此，系统通常使用较弱的隔离级别来防止一部分，而不是全部的并发问题。</p><h3 id="读已提交" tabindex="-1"><a class="header-anchor" href="#读已提交" aria-hidden="true">#</a> 读已提交</h3><p>最基本的事务隔离级别时  <strong>读已提交（Read Committed）</strong>，它有两个保障：</p><ol><li>从数据库读时，只能看到已提交的数据（没有 <strong>脏读</strong>，即 dirty reads）。</li><li>写入数据库时，只会覆盖已经写入的数据（没有 <strong>脏写</strong>，即 dirty writes）。</li></ol><h4 id="脏读" tabindex="-1"><a class="header-anchor" href="#脏读" aria-hidden="true">#</a> 脏读</h4><p>如果一个事务可以看到另一个事务未提交的数据，那么我们称之为脏读。</p><p><strong>读已提交</strong>必须防止脏读。即，事务的任何写入操作只有提交后，别人才能看到。</p><p><img src="http://ddia.vonng.com/img/fig7-4.png" alt="图1"></p><h4 id="脏写" tabindex="-1"><a class="header-anchor" href="#脏写" aria-hidden="true">#</a> 脏写</h4><p>如果两个事务如果两个事务同时尝试更新数据库中的相同对象，会发生什么情况？</p><p>我们不知道写入的顺序是怎样的，但是我们通常认为后面的写入会覆盖前面的写入。</p><p>在 <strong>读已提交</strong> 的隔离级别上运行的事务必须防止脏写，通常是延迟第二次写入，直到第一次写入事务提交或中止为止。</p><p>通过防止脏写，避免了一些并发问题：</p>',31),m=n("li",null,[n("p",null,"如果事务更新多个对象，脏写会导致不好的结果")],-1),b={href:"http://ddia.vonng.com/img/fig7-4.png",target:"_blank",rel:"noopener noreferrer"},_=o(`<p>我们来看下图：</p><p>Alice 和 Bob 两个人同时试图购买同一辆车。购买汽车需要两次数据库写入：网站上的商品列表需要更新，以反映买家的购买，销售发票需要发送给买家。销售是属于 Bob 的（因为他成功更新了商品列表），但发票却寄送给了爱丽丝（因为她成功更新了发票表）。读已提交会<strong>阻止</strong>这样的事故。</p><p><img src="http://ddia.vonng.com/img/fig7-5.png" alt=""></p><p><strong>如果存在脏写，来自不同事务的冲突写入可能会混淆在一起</strong></p><h4 id="实现读已提交" tabindex="-1"><a class="header-anchor" href="#实现读已提交" aria-hidden="true">#</a> 实现读已提交</h4><p><strong>读已提交</strong> 是一个非常流行的隔离级别。这是 Oracle 11g、PostgreSQL、SQL Server 2012、MemSQL 和其他许多数据库的默认设置。</p><ul><li>如何防止脏写？</li></ul><p>大部分数据库通过<strong>行锁</strong>(row-level lock)来防止<strong>脏写</strong>:当事务想要修改特定行时，它必须首先<strong>获得</strong>该<strong>行</strong>的<strong>锁</strong>，然后必须<strong>持有</strong>该锁直到事务被<strong>提交或中止</strong>。一次只有一个事务持有某一行的锁，如果另一个事务要写入同一行，必须等待第一个事务提交或中止，才能获取行锁并继续。</p><ul><li>如何防止脏读？</li></ul><p>一种选择是使用相同的锁，读行前先获取到行锁，然后读取完立即释放。这将确保不会读取到未提交的行(因为如果有未提交的事务，锁将由进行写入的事务一直持有，读事务获取不到锁)。</p><p>但是要求读锁的办法实践中效果并不好，因为一个长写入事务会迫使很多只读事务等待长写入事务完成。</p><p>出于这个原因，大多数数据库采用 图1 的方式防止脏读：对于每个写入行，数据库只会记住<strong>旧的已提交值</strong>，和有当前持有锁事务写入的新值。当写入事务进行时，其他事务读取行都只会拿到旧值。当写入事务提交后，其他事务才能拿到新值。</p><h3 id="可重复读" tabindex="-1"><a class="header-anchor" href="#可重复读" aria-hidden="true">#</a> 可重复读</h3><p>读已提交允许中止，防止读取不完整的事务结果（脏读），防止并发写入造成混乱（脏写）。这些功能很有用，但是使用此隔离界别，一些地方仍然可能出现并发错误。</p><p><img src="http://ddia.vonng.com/img/fig7-6.png" alt=""></p><p>读取偏差</p><p>Alice 有两个500块的账户。现在一个事务从账户2转到了账户1.如果她在事务处理过程中查看账户余额列表，她可能会在转账之前先看到账户1余额（500），转账完成后看到另一个账户余额（400）。对于Alice，她的账户余额似乎只有900了--有100块消失了。</p><p>这种异常成为不可重复读或读取偏差。如果Alice 在事务结束后再次读取账户1的余额，她将看到600。在<strong>读已提交</strong>的隔离条件下，<strong>不可重复读</strong> 被认为是可接受的：Alice 看到的帐户余额时确实在阅读时已经提交了。</p><p>对于 Alice 来说，这不是一个长久持续的问题，几秒钟后，她再次刷新页面，她就可能看到一致的账户余额。</p><p>但是有些情况下，不能容忍短暂的不一致：</p><ul><li>备份</li></ul><p>如果备份进程运行时，数据库仍然接收写操作，备份可能包含一些旧数据和新数据。如果从这样的备份中恢复，不一致（消失的money）就会变成永久的。</p><ul><li>分析查询和完整性检查</li></ul><p>如果查询需要扫描大部分数据，如果这些查询在不同时间点观察数据库的不同部分，可能会返回错误的结果。</p><p><strong>快照隔离（snapshot isolation）</strong> 是这个问题最常见的解决方案。思路是，每个事务从数据库的<strong>一致快照（consistent snapshot）</strong> 中读取 —— 一个事务可以看到该事务开始时数据库中所有已提交的数据，即使这些数据随后被另一个事务更改，该事务也只能看到开始时的数据。</p><h4 id="实现快照隔离" tabindex="-1"><a class="header-anchor" href="#实现快照隔离" aria-hidden="true">#</a> 实现快照隔离</h4><p>与读已提交的隔离类似，使用<strong>写锁</strong>来防止<strong>脏写</strong>，即写入同一行必须先持有行锁，行锁只能由一个事务持有。</p><p>但是，读取不需要任何锁定。即，<strong>读不阻塞写，写不阻塞读</strong>。</p><p>为了实现快照隔离，数据库同时维护着一行数据的</p><p>多个版本，这种计数成为 <strong>多版本并发控制（MVCC, multi-version concurrency control）</strong>。</p><p>如果一个数据库只需要提供 <strong>读已提交</strong> 的隔离级别，而不提供 <strong>快照隔离</strong>，那么保留一个对象的两个版本就足够了：提交的版本和被覆盖但尚未提交的版本。支持快照隔离的存储引擎通常也使用 MVCC 来实现 <strong>读已提交</strong> 隔离级别。一种典型的方法是 <strong>读已提交</strong> 为每个查询使用单独的快照，而 <strong>快照隔离</strong> 对整个事务使用相同的快照。</p><p>我们看一下 InnoDB 是如何实现的。</p><p>当事务开始时，会赋予一个唯一的事务 ID，叫做 <code>transaction id</code>, 它按照申请顺序严格递增。</p><p>每行数据也都是有多个版本的。每次事务更新，都会生产一个新的数据版本，并且把事务的 <code>tansaction id</code>赋值给行数据的事务ID，记为<code>rot trx_id</code>.即数据表中的每一个，都可能有多个版本(row),每个版本有自己的 <code>row trx_id</code>.</p><h3 id="防止丢失更新" tabindex="-1"><a class="header-anchor" href="#防止丢失更新" aria-hidden="true">#</a> 防止丢失更新</h3><p>并发的写入事务之间还有其他几种有趣的冲突。其中最着名的是 <strong>丢失更新（lost update）</strong> 问题。</p><p>如果应用从数据库读取一些值，修改它并写回修改的值（读取-修改-写入），则可能发生<strong>更新丢失</strong>的问题。如果两个事务同时执行，则其中一个的修改可能丢失，因为第二个写入内容没有包括第一个事务的修改。这种模式发生在各种不同的情况下：</p><ul><li><p>增加计数器或者更新账户余额（读取当前值，计算新值，写入新值）</p></li><li><p>复杂值进行本地修改,例如，将元素添加到 JSON 文档中的一个列表（需要解析文档，进行更改并写回修改的文档）</p></li><li><p>两个用户同时编辑 wiki 页面，每个用户通过将整个页面内容发送到服务器来保存其更改，覆写数据库中当前的任何内容。</p></li></ul><p>这是普遍问题，我们也有一些解决方案。</p><h5 id="原子写入" tabindex="-1"><a class="header-anchor" href="#原子写入" aria-hidden="true">#</a> 原子写入</h5><p>使用数据库的提供的原子更新操作，消除在应用程序代码中执行读取 - 修改 - 写入序列的需要.如果可以使用这些操作来表达，通常是最好的解决方案。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">UPDATE</span> counters <span class="token keyword">SET</span> <span class="token keyword">value</span> <span class="token operator">=</span> <span class="token keyword">value</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">WHERE</span> <span class="token keyword">key</span> <span class="token operator">=</span> <span class="token string">&#39;foo&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>类似的，类似地，像 MongoDB 这样的文档数据库提供了对 JSON 文档的一部分进行本地修改的原子操作，Redis 提供了修改数据结构（如优先级队列）的原子操作, 依赖<strong>数据库</strong>的实现。</p><h4 id="显式锁定" tabindex="-1"><a class="header-anchor" href="#显式锁定" aria-hidden="true">#</a> 显式锁定</h4><p>让应用程序显式地锁定要修改的行，然后执行读取 - 修改 - 写入序列，如果其他事务尝试读取同一行，则强制等待，直到第一个 读取 - 修改 - 写入 完成。</p><p>具体来说就是使用 <code>for update</code></p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">BEGIN</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> figures
  <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;robot&#39;</span> <span class="token operator">AND</span> game_id <span class="token operator">=</span> <span class="token number">222</span>
<span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>

<span class="token comment">-- 检查玩家的操作是否有效，然后更新先前 SELECT 返回棋子的位置。</span>
<span class="token keyword">UPDATE</span> figures <span class="token keyword">SET</span> position <span class="token operator">=</span> <span class="token string">&#39;c4&#39;</span> <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1234</span><span class="token punctuation">;</span>
<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><code>FOR UPDATE</code> 子句告诉数据库应该对该查询返回的所有行加锁。</li></ul><h4 id="自动检测丢失的更新" tabindex="-1"><a class="header-anchor" href="#自动检测丢失的更新" aria-hidden="true">#</a> 自动检测丢失的更新</h4><p>原子操作和锁是通过强制 <strong>读取 - 修改 - 写入序列</strong> 按顺序发生，来防止丢失更新的方法。另一种方法是允许它们并行执行，如果事务管理器检测到丢失更新，则中止事务并强制它们重试其 <strong>读取 - 修改 - 写入序列</strong>。</p><p>这种方法的一个优点是，数据库可以结合快照隔离高效地执行此检查。事实上，PostgreSQL 的可重复读，Oracle 的可串行化和 SQL Server 的快照隔离级别，都会自动检测到丢失更新，并中止惹麻烦的事务。但是，<strong>MySQL/InnoDB</strong> 的可重复读并不会检测 <strong>丢失更新</strong>。</p><h4 id="cas" tabindex="-1"><a class="header-anchor" href="#cas" aria-hidden="true">#</a> CAS</h4><p>Compare And Set，只有当值匹配才允许更新。如果当前值与先前读的值不匹配，则更新不起作用，且必须重试 读取 - 修改 - 写入序列。</p><p>可以在表里添加 version 字段，实现乐观锁。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">UPDATE</span> wiki_pages <span class="token keyword">SET</span> content <span class="token operator">=</span> <span class="token string">&#39;新内容&#39;</span><span class="token punctuation">,</span>version<span class="token operator">=</span>version<span class="token operator">+</span><span class="token number">1</span>
  <span class="token keyword">WHERE</span> id <span class="token operator">=</span> <span class="token number">1234</span> <span class="token operator">AND</span> version<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 version 发生变更，则此更新不起作用，此时要检查更新是否生效，选择中止事务或者重试。</p><p>但是，如果数据库允许 <code>WHERE</code> 子句从旧快照中读取, 此语句无法方式丢失更新。</p><p>CAS依赖数据库的实现。</p><h4 id="写入偏差和幻读" tabindex="-1"><a class="header-anchor" href="#写入偏差和幻读" aria-hidden="true">#</a> 写入偏差和幻读</h4><p>由于事务的并发写相同行，我们看到了<strong>脏写</strong>和<strong>丢失更新</strong>，为了避免数据损坏，这些些竞争条件需要被阻止 —— 既可以由数据库自动执行，也可以通过锁和原子写操作这类手动安全措施来防止。</p><p>并发写之间的竞态条件还没完，还有一起更微妙的冲突。</p><p>假设，Alice 和 Bob 是两位值班医生。两人都感到不适，所以他们都决定请假。不幸的是，他们恰好在同一时间点击按钮下班。</p><p><img src="http://ddia.vonng.com/img/fig7-8.png" alt=""></p><p>在两个事务中，应用首先检查是否有两个或以上的医生正在值班；如果是的话，它就假定一名医生可以安全地休班。由于数据库使用快照隔离，两次检查都返回 2 ，所以两个事务都进入下一个阶段。Alice 更新自己的记录休班了，而 Bob 也做了一样的事情。两个事务都成功提交了，现在没有医生值班了。违反了至少有一名医生在值班的要求。</p><p>这种异常 <strong>写偏差</strong>。它既不是 <strong>脏写</strong>，也不是 <strong>丢失更新</strong>，因为这两个事务正在更新两个不同的对象（Alice 和 Bob 各自的待命记录）。在这里发生的冲突并不是那么明显，但是这显然是一个竞争条件：如果两个事务一个接一个地运行，那么第二个医生就不能歇班了。异常行为只有在事务并发进行时才有可能。</p><p>写入偏差可以视为更新丢失问题的一般化。如果两个事务读取相同的行，然后更新其中一些行，则可能发生写入偏差。多个事务更新同一行的情况下，就会发生脏写或丢失更新。</p><p>对于写偏差，我们的选择更受限制：</p><ul><li><p>由于涉及多行，单行的原子操作不起作用。</p></li><li><p>自动检测丢失更新对比没有帮助。只有真正的串行执行才能自动防止写偏差。</p></li><li><p>某些数据库允许配置约束，例如唯一键、外键或特定值约束。但是大多数数据库没有内置对多对象约束的支持。</p></li><li><p>如果无法使用串行话隔离级别，次优可能是显式锁定事务所有依赖行</p></li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">BEGIN</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>
<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> doctors
  <span class="token keyword">WHERE</span> on_call <span class="token operator">=</span> <span class="token boolean">TRUE</span>
  <span class="token operator">AND</span> shift_id <span class="token operator">=</span> <span class="token number">1234</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span>

<span class="token keyword">UPDATE</span> doctors
  <span class="token keyword">SET</span> on_call <span class="token operator">=</span> <span class="token boolean">FALSE</span>
  <span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&#39;Alice&#39;</span>
  <span class="token operator">AND</span> shift_id <span class="token operator">=</span> <span class="token number">1234</span><span class="token punctuation">;</span>

<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>写偏差的更多例子</strong></p><ul><li>会议室预订系统</li></ul><p>比如你想要规定不能在同一时间对同一个会议室进行多次的预订。</p><p>当有人想要预订时，首先检查是否存在相互冲突的预订（即预订时间范围重叠的同一房间），如果没有找到，则创建会议。</p><p>可重复读下不安全</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">BEGIN</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>

<span class="token comment">-- 检查所有现存的与 12:00~13:00 重叠的预定</span>
<span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> bookings
<span class="token keyword">WHERE</span> room_id <span class="token operator">=</span> <span class="token number">123</span> <span class="token operator">AND</span>
  end_time <span class="token operator">&gt;</span> <span class="token string">&#39;2015-01-01 12:00&#39;</span> <span class="token operator">AND</span> start_time <span class="token operator">&lt;</span> <span class="token string">&#39;2015-01-01 13:00&#39;</span><span class="token punctuation">;</span>

<span class="token comment">-- 如果之前的查询返回 0</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> bookings<span class="token punctuation">(</span>room_id<span class="token punctuation">,</span> start_time<span class="token punctuation">,</span> end_time<span class="token punctuation">,</span> user_id<span class="token punctuation">)</span>
  <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token string">&#39;2015-01-01 12:00&#39;</span><span class="token punctuation">,</span> <span class="token string">&#39;2015-01-01 13:00&#39;</span><span class="token punctuation">,</span> <span class="token number">666</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>不幸的是，如果两个用户同时操作，又可能同时预定一个房间了。</p><ul><li>用户名重复</li></ul><p>比如规定用户名在系统里要唯一。</p><p>当要创建用户名是，首先要检查用户名是否存在，如果不存在，才创建成功。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">BEGIN</span> <span class="token keyword">TRANSACTION</span><span class="token punctuation">;</span>

<span class="token comment">-- 检查所有现存的 hasagei</span>
<span class="token keyword">SELECT</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">FROM</span> users
<span class="token keyword">WHERE</span> name <span class="token operator">=</span> <span class="token string">&quot;hasagei&quot;</span><span class="token punctuation">;</span>

<span class="token comment">-- 如果之前的查询返回 0</span>
<span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> hasagei<span class="token punctuation">(</span>id<span class="token punctuation">,</span>name<span class="token punctuation">)</span>
  <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token string">&quot;hasagei&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">COMMIT</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>幸运的是，唯一约束是个简单的解决方案。INSERT SQL 会因为违反了唯一约束抛出异常，导致事务回滚。</p><ul><li>双重消费</li></ul><p>用户花钱的服务，必须检查用户的支付数额不超过其余额。</p><p>先插入一条消费记录，并汇总账户的所有账目，并检查总和是否为正，为正才可以提交事务。</p><p>有了写入偏差，可能会发生两个消费记录同时插入，导致余额变成负数。</p><h5 id="幻读" tabindex="-1"><a class="header-anchor" href="#幻读" aria-hidden="true">#</a> 幻读</h5><p>上面的例子都遵循一个模式：</p><ol><li><p>SELECT 符合条件的行，检查是否符合要求</p></li><li><p>按照第一个查询结果，应用程序决定是否继续执行（可以中止，也可以继续执行）</p></li><li><p>如果继续执行，执行写入操作，并提交事务。</p></li></ol><p>第3步的写入操作改变了步骤2的先决条件。即，在提交写入后，重复执行步骤1的 <code>SELECT</code>，会得到不同的结果。</p><p>这些步骤可能以不同顺序执行。例如双重消费的例子，可以先写入，再执行<code>SELECT</code>，最后根据结果决定提交或者放弃。</p><p><strong>一个事务的写入改变另一个事务搜索查询的结果</strong>，称为<strong>幻读</strong>。可重复读避免了只读查询中的幻读，但是读写事务，幻读会导致写入偏差的发生。</p><h5 id="物化冲突" tabindex="-1"><a class="header-anchor" href="#物化冲突" aria-hidden="true">#</a> 物化冲突</h5><p>如果幻读的问题是因为没有对象可以加锁，那么我们可以人为的在数据库引入锁对象。</p><p>例如，在会议室预定场景中，可以想象创建一个关于时间槽和房间的表。此表中的每一行对应于特定时间段（例如 15 分钟）的特定房间。可以提前插入房间和时间的所有可能组合行（例如接下来的六个月）。</p><p>现在，要创建预订的事务可以锁定（<code>SELECT FOR UPDATE</code>）表中与所需房间和时间段对应的行。在获得锁定之后，它可以检查重叠的预订并像以前一样插入新的预订。请注意，这个表并不是用来存储预订相关的信息 —— 它完全就是一组锁，用于防止同时修改同一房间和时间范围内的预订。</p><p>这种方法被称为 <strong>物化冲突（materializing conflicts）</strong>，因为它将幻读变为数据库中一组具体行上的锁冲突。</p><p>不幸的是，弄清楚如何物化冲突可能很难，也很容易出错，而让并发控制机制泄漏到应用数据模型是很丑陋的做法。出于这些原因，如果没有其他办法可以实现，物化冲突应被视为<strong>最后的手段</strong>。在大多数情况下。<strong>可串行化（Serializable）</strong> 的隔离级别是更可取的。</p><h2 id="可串行化" tabindex="-1"><a class="header-anchor" href="#可串行化" aria-hidden="true">#</a> 可串行化</h2><p>读已提交 和 可重复读 会阻止某些竞态条件，但不会阻止另外一些。例如 写入偏差 和 幻读。</p><p>一直以来，都是一个答案： 使用 <strong>可串行化（serializable）</strong> 的隔离级别！</p><p>如果可串行化比弱隔离界要好的多，为什么没人用呢？我们看看可串行化的具体实现</p><ul><li><p>字面意义串行执行（单线程）</p></li><li><p>两阶段锁定（2PL two-phase locking)</p></li></ul><h4 id="真串行" tabindex="-1"><a class="header-anchor" href="#真串行" aria-hidden="true">#</a> 真串行</h4><p>避免并发问题最简单的方案是不要并发，即单线程执行所有事务。</p><h2 id="_2pl" tabindex="-1"><a class="header-anchor" href="#_2pl" aria-hidden="true">#</a> 2PL</h2><p>大约 30 年来，在数据库中只有一种广泛使用的串行化算法：<strong>两阶段锁定（2PL，two-phase locking）</strong> 。</p>`,106),E={id:"_2pl不是2pc",tabindex:"-1"},A=n("a",{class:"header-anchor",href:"#_2pl不是2pc","aria-hidden":"true"},"#",-1),f={href:"http://ddia.vonng.com/#/ch7?id=_2pl%e4%b8%8d%e6%98%af2pc",target:"_blank",rel:"noopener noreferrer"},y=n("p",null,"请注意，虽然两阶段锁定（2PL）听起来非常类似于两阶段提交（2PC），但它们是完全不同的东西。",-1),w=o(`<p>只要没有写入，就允许多个事务同时读取同一个对象。但对象只要有写入（修改或删除），就需要 <strong>独占访问（exclusive access）</strong> 权限：</p><ul><li><p>如果事务 A 读取了一个对象，并且事务 B 想要写入该对象，那么 B 必须等到 A 提交或中止才能继续（这确保 B 不能在 A 底下意外地改变对象）。</p></li><li><p>如果事务 A 写入了一个对象，并且事务 B 想要读取该对象，则 B 必须等到 A 提交或中止才能继续（读取旧版本的对象在 2PL 下是不可接受的）。</p></li></ul><p>在 2PL 中，写入不仅会阻塞其他写入，也会阻塞读，反之亦然。快照隔离使得 <strong>读不阻塞写，写也不阻塞读</strong>，这是 2PL 和快照隔离之间的关键区别。另一方面，因为 2PL 提供了可串行化的性质，它可以防止早先讨论的所有竞争条件，包括丢失更新和写入偏差。</p><h4 id="_2pl-的实现" tabindex="-1"><a class="header-anchor" href="#_2pl-的实现" aria-hidden="true">#</a> 2PL 的实现</h4><p>2PL 用于 MySQL（InnoDB）和 SQL Server 中的可串行化隔离级别，以及 DB2 中的可重复读隔离级别。</p><p>读写阻塞是通过数据库为每个对象加锁实现的。锁可以处于 <strong>共享模式（shared mode）</strong> 或 <strong>独占模式（exclusive mode）</strong>。</p><ul><li><p>若事务读对象，必须先以共享模式获取锁。允许多个事务同时持有共享锁。但如果另一个事务持有对象的排他锁，读事务必须等待。</p></li><li><p>若事务写入对象，必须以独占模式获取锁。没有其他事务可以同时持有锁（无论是共享模式还是独占模式）,例如事务A持有读锁，事务B不能获得独占锁了，只有事务A可以升级为独占锁。如果对象上持有任何锁，呢么该事务必须等待。（避免了数据被修改）</p></li><li><p>如果事务先读取再写入对象，则它可能会将其共享锁升级为独占锁。升级锁的工作与直接获得独占锁相同。</p></li><li><p>事务获得锁之后，必须继续持有锁直到事务结束（提交或中止）。这就是 “两阶段” 这个名字的来源：<strong>第一阶段（当事务正在执行时）获取锁，第二阶段（在事务结束时）释放所有的锁</strong>。</p></li></ul><h4 id="_2pl-性能" tabindex="-1"><a class="header-anchor" href="#_2pl-性能" aria-hidden="true">#</a> 2PL 性能</h4><p>2PL 的两阶段锁定的巨大缺点，以及 70 年代以来没有被所有人使用的原因，是其性能问题。两阶段锁定下的事务吞吐量与查询响应时间要比弱隔离级别下要差得多。</p><p>一部分是获取和释放锁的开心，更重要的是因为并发性的降低。</p><h3 id="谓词锁" tabindex="-1"><a class="header-anchor" href="#谓词锁" aria-hidden="true">#</a> 谓词锁</h3><p>写入偏差时由幻读导致的，即一个事务改变另一个事务的搜索查询的结果。具有可串行化隔离级别的数据库必须防止 <strong>幻读</strong>。</p><p><strong>谓词锁（predicate lock）</strong>，类似于 共享/排他 锁，但不属于具体的对象，它数据符合某些搜索条件的对象。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> bookings
<span class="token keyword">WHERE</span> room_id <span class="token operator">=</span> <span class="token number">123</span> <span class="token operator">AND</span>
      end_time <span class="token operator">&gt;</span> <span class="token string">&#39;2018-01-01 12:00&#39;</span> <span class="token operator">AND</span>
      start_time <span class="token operator">&lt;</span> <span class="token string">&#39;2018-01-01 13:00&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>谓词锁限制访问，如下所示：</p><ul><li><p>如果事务 A 想要读取匹配某些条件的对象，就像在这个 <code>SELECT</code> 查询中那样，它必须获取查询条件上的 <strong>共享谓词锁（shared-mode predicate lock）</strong>。如果另一个事务 B 持有任何满足这一查询条件对象的排它锁，那么 A 必须等到 B 释放它的锁之后才允许进行查询。</p></li><li><p>如果事务 A 想要插入，更新或删除任何对象，则必须首先检查旧值或新值是否与任何现有的谓词锁匹配。如果事务 B 持有匹配的谓词锁，那么 A 必须等到 B 已经提交或中止后才能继续。</p></li></ul><p>这里的关键思想是，谓词锁甚至适用于数据库中尚不存在，但将来可能会添加的对象（幻象）。如果两阶段锁定包含谓词锁，则数据库将阻止所有形式的写入偏差和其他竞争条件，因此其隔离实现了可串行化。</p><h3 id="索引范围锁-间隙锁" tabindex="-1"><a class="header-anchor" href="#索引范围锁-间隙锁" aria-hidden="true">#</a> 索引范围锁（间隙锁）</h3><p>谓词锁会存在性能问题：<strong>如果活跃事务持有很多锁，检查匹配的锁会非常耗时。</strong> 因此，大多数实现 2PL 的数据实现了索引范围锁（index-range locking，也称为 <strong>next-key locking</strong>），这是一个简化的近似版谓词锁。</p><p>通过使谓词匹配到一个更大范围的集合来简化谓词锁时安全的。如，如果你有在中午和下午 1 点之间预订 123 号房间的谓词锁，则锁定 123 号房间的所有时间段，或者锁定 12:00~13:00 时间段的所有房间（不只是 123 号房间）是一个安全的近似，因为任何满足原始谓词的写入也一定会满足这种更松散的近似。</p><p>在房间预定数据库中，<code>room_id</code>列上应该有一个索引，并且 / 或者在 <code>start_time</code> 和 <code>end_time</code> 上有索引（否则前面的查询在大型数据库上的速度会非常慢）：</p><ul><li><p>假设你的索引位于 <code>room_id</code> 上，并且数据库使用此索引查找 123 号房间的现有预订。现在数据库可以简单地将共享锁附加到这个索引项上，指示事务已搜索 123 号房间用于预订。</p></li><li><p>或者，如果数据库使用基于时间的索引来查找现有预订，那么它可以将共享锁附加到该索引中的一系列值，指示事务已经将 12:00~13:00 时间段标记为用于预定。</p></li></ul><p>无论哪种方式，搜索条件的近似值都附加到其中一个索引上。现在，如果另一个事务想要更新同一个房间和 / 或重叠时间段的预订，它不得不更新索引的相同部分，这个过程中，它会遇到共享间隙锁，它将被迫等待锁释放。</p><p>如果没有可以挂载范围锁的索引，数据库将退化到表锁。这对性能不利，但它是个安全的回退位置。</p><p>InnoDB 在弱隔离级别下，使用 <code>for update</code> 会使用到<strong>间隙锁</strong>，防止幻读。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>ACID</p><p>并发控制</p><ul><li><p>脏读</p></li><li><p>脏写</p></li><li><p>不可重复读</p></li><li><p>更新丢失</p></li><li><p>写偏差</p></li><li><p>幻读</p></li></ul><h2 id="参考文档" tabindex="-1"><a class="header-anchor" href="#参考文档" aria-hidden="true">#</a> 参考文档</h2>`,30),x={href:"http://ddia.vonng.com/#/ch7?id=%e5%8f%af%e4%b8%b2%e8%a1%8c%e5%8c%96",target:"_blank",rel:"noopener noreferrer"};function S(C,T){const a=t("ExternalLinkIcon");return r(),i("div",null,[c,n("p",null,[s("相比之下，ACID 的原子性并 "),d,s(" 是关于 "),u,s(" 的。它并不是在描述如果几个进程试图同时访问相同的数据会发生什么情况，这种情况包含在缩写 "),g,s(" 中，即 "),n("a",k,[h,e(a)]),s("。")]),v,n("ul",null,[m,n("li",null,[n("p",null,[s("读已提交并不能防止 "),n("a",b,[s("图 1"),e(a)]),s("两个计数器增量之间的竞争状态。")])])]),_,n("blockquote",null,[n("h4",E,[A,s(),n("a",f,[s("2PL不是2PC"),e(a)])]),y]),w,n("p",null,[n("a",x,[s("设计数据密集型应用"),e(a)])])])}const L=p(l,[["render",S],["__file","事务.html.vue"]]);export{L as default};
