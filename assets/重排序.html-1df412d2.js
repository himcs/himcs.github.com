import{_ as e,p as r,q as t,a1 as n}from"./framework-fa6fd9c7.js";const a={},s=n(`<h1 id="重排序" tabindex="-1"><a class="header-anchor" href="#重排序" aria-hidden="true">#</a> 重排序</h1><h2 id="什么是重排序" tabindex="-1"><a class="header-anchor" href="#什么是重排序" aria-hidden="true">#</a> 什么是重排序？</h2><p>计算机在执行程序时，为了提高执行<strong>效率</strong>，<strong>编译器</strong>和<strong>处理器</strong>会对<strong>指令</strong>进行<strong>重排</strong>。</p><h3 id="为什么重排序可提高性能" tabindex="-1"><a class="header-anchor" href="#为什么重排序可提高性能" aria-hidden="true">#</a> 为什么重排序可提高性能？</h3><p>现代CPU使用流水线技术，多个指令可以同时执行。</p><p>例如下面的代码</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>a = b + c;
d = e - f;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>先加载 b,c 但在执行 b + c 的时候，需要等待 b,c 加载完成，也就也是增加了停顿，后面的指令在等待 b + c 完成。</p><p>为了减少停顿，我们可以先加载 e，f 然后再加载 b + c。这对程序执行没有影响，却提高了效率。</p><p>指令重排带了了<strong>乱序</strong>的问题，但大大提高了CPU的执行<strong>效率</strong>。</p><p>指令重排一般有三种:</p><ul><li><strong>编译器</strong>优化重排</li></ul><p>不改<strong>单线程程序语义</strong>的情况下，重新安排指令的执行顺序。</p><ul><li><strong>CPU</strong>指令并行重排</li></ul><p>如果指令间不存在数据依赖（后面的语句依赖前面的结果），CPU可以改变<strong>机器指令</strong>的执行顺序。</p><ul><li><strong>内存</strong>系统重排</li></ul><p>因为CPU使用缓存，是的 load 和 store 操作看上去在乱序执行，因为三级缓存的存在，导致内存和缓存的同步存在时间差。</p><p><strong>指令重排</strong>可以保证<strong>串行语义一致</strong>，但<strong>没有</strong>义务<strong>保证多线程</strong>的<strong>语义</strong>也<strong>一致</strong>。</p><h2 id="顺序一致性" tabindex="-1"><a class="header-anchor" href="#顺序一致性" aria-hidden="true">#</a> 顺序一致性</h2><p>顺序一致性:</p><ul><li>一个线程中所有操作必须按照程序的顺序来执行</li><li>不管程序是否同步，所有线程只能看到一个单一的执行顺序。即<strong>每个操作是原子的，并立刻对所有线程可见</strong>。</li></ul><p><strong>JMM 并没有提供这样保证</strong>。</p><h2 id="jmm-顺序一致性" tabindex="-1"><a class="header-anchor" href="#jmm-顺序一致性" aria-hidden="true">#</a> JMM 顺序一致性</h2><h3 id="同步程序" tabindex="-1"><a class="header-anchor" href="#同步程序" aria-hidden="true">#</a> 同步程序</h3><p>JMM 中，临界区内的代码可以发生重排序。</p><p>JMM 会在进入和退出临界区做特殊处理，使得在临界区内程序获得与<strong>顺序一致性</strong>模型<strong>相同的内存视图</strong>。</p><p>JMM的具体实现方针是：<strong>在不改变（正确同步的）程序执行结果的前提下，尽量为编译期和处理器的优化打开方便之门</strong>。</p><h3 id="未同步的程序" tabindex="-1"><a class="header-anchor" href="#未同步的程序" aria-hidden="true">#</a> 未同步的程序</h3><p>JMM 提供<strong>最小安全性</strong>：</p><p>线程读到的值</p><ul><li>要么是默认值</li><li>要么是之前某个线程写入的值</li></ul><p>JMM <strong>不保证</strong> <strong>未同步程序</strong> 执行<strong>结果</strong>与该程序<strong>顺序一致性</strong>执行结果<strong>一致</strong>。</p><p>未同步程序在 JMM 和 顺序一致性 执行差异：</p><table><thead><tr><th></th><th>顺序一致性</th><th>JMM</th></tr></thead><tbody><tr><td>单线程</td><td>按照程序顺序执行</td><td>不保证按照程序顺序执行，但保证重排序不影响结果。</td></tr><tr><td>操作执行顺序</td><td>保证所有线程看到一致的顺序</td><td>不保证所有线程看到一致的执行顺序（JMM 不保证所有操作立即可见）</td></tr><tr><td>内存</td><td>内存读写原子性</td><td>不保证 64 位的 long 和 double 类型写操作原子性。</td></tr></tbody></table><h2 id="happens-before" tabindex="-1"><a class="header-anchor" href="#happens-before" aria-hidden="true">#</a> happens-before</h2><h3 id="什么是-haapens-before" tabindex="-1"><a class="header-anchor" href="#什么是-haapens-before" aria-hidden="true">#</a> 什么是 haapens-before</h3><p>一方面，程序员需要 JMM 提供一个强的内存模型来编写代码；另一方面，编译器和处理器希望 JMM 的束缚越少越好，这样它们可以做尽可能多的优化，希望有一个弱的内存模型。</p><p>JMM 考虑了这两种需求，找到了平衡点，对编译器和处理器来说：<strong>只要不改变程序的执行结果（单线程程序和正确同步了的多线程程序），编译器和处理器怎么优化都行。</strong></p><p>对于程序员，JMM 提供了 <strong>happens-before规则</strong>（JSR-133规范），简单易懂，并提供了足够强的内存可见性保证。</p><p>JMM 使用 happens-before 的概念来定制两个操作间的执行顺序。这两个操作可以在一个线程以内，也可以是不同的线程之间。因此，JMM可以通过happens-before关系向程序员提供跨线程的内存可见性保证。</p><p>happens-before 定义：</p><ul><li>如果一个操作 happens-before 另一个操作，第一个操作执行结果对第二个操作可见，且第一个操作操作的执行顺序排在第二个操作之前。</li><li>两个操作存在 happens-before 关系，并不意味着 Java 平台的具体实现按照 happens-before 指定顺序执行。在保证结果一致的前提下，JMM 也运行重排序。</li></ul><p>简而言之，如果 <strong>A happens-before B</strong>, 那么 <strong>A</strong> 在<strong>内存</strong>上所做的操作对于 <strong>B</strong> 都是<strong>可见</strong>的，不管它们在不在一个线程中。</p><h3 id="天然的-happens-before-关系" tabindex="-1"><a class="header-anchor" href="#天然的-happens-before-关系" aria-hidden="true">#</a> 天然的 happens-before 关系</h3><ul><li>程序顺序：一个线程中每一个操作，happens-before 该线程中任意后续操作</li><li>监视器锁: 一个锁的解锁，happens-before 随后对改锁的加锁</li><li>volatile：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读</li><li>传递性: A happens-before B, B happens-before C, 那么 A happens-before C</li><li>start: 线程 A 执行 threadB.start() , threadB.start() 操作 happens-before 于 B的任意操作</li><li>join: 线程 A 执行 threadB.join(), 线程B的任意操作 happens-before 于线程A从 threadB.join()的返回。</li></ul>`,45),o=[s];function p(h,d){return r(),t("div",null,o)}const l=e(a,[["render",p],["__file","重排序.html.vue"]]);export{l as default};
