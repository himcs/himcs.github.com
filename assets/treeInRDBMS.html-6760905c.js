import{_ as e,p as t,q as a,a1 as s}from"./framework-fa6fd9c7.js";const i={},d=s(`<h1 id="tree-in-rdbms" tabindex="-1"><a class="header-anchor" href="#tree-in-rdbms" aria-hidden="true">#</a> Tree in Rdbms</h1><h2 id="邻接表" tabindex="-1"><a class="header-anchor" href="#邻接表" aria-hidden="true">#</a> 邻接表</h2><p><img src="https://bitworks.software/assets/img/2017-10-20/intuitive-adjacency.png" alt="Adjacency list"></p><p>每个节点存储父节点</p><table><thead><tr><th>code</th><th>pid</th><th>name</th></tr></thead><tbody><tr><td>1</td><td>NULL</td><td>TOP</td></tr><tr><td>2</td><td>1</td><td>SEC</td></tr><tr><td>3</td><td>1</td><td>SEC_2</td></tr></tbody></table><p>查询子节点：递归</p><p>获取到root的路径：递归</p><p>检查两个节点关系：递归</p><p>优点：</p><ul><li>数据结构简单</li><li>增删改简单</li></ul><p>缺点：</p><ul><li>查询复杂</li></ul><h2 id="subsets" tabindex="-1"><a class="header-anchor" href="#subsets" aria-hidden="true">#</a> Subsets</h2><p><img src="https://bitworks.software/assets/img/2017-10-20/intuitive-subsets.png" alt="Subsets"></p><p>表保存所有的父类依赖关系</p><p>缺点：</p><ul><li><p>数据冗余</p></li><li><p>查询复杂</p></li></ul><h2 id="nested-sets" tabindex="-1"><a class="header-anchor" href="#nested-sets" aria-hidden="true">#</a> Nested sets</h2><p><img src="https://bitworks.software/assets/img/2017-10-20/intuitive-nested.png" alt="Nested sets"></p><p>存储树的前序遍历，</p><p>优点：查询不使用递归</p><p>缺点：插入或修改时，整棵树都要进行编辑。可以使用较大间隔来优化</p><h2 id="materialized-paths" tabindex="-1"><a class="header-anchor" href="#materialized-paths" aria-hidden="true">#</a> Materialized paths</h2><p><img src="https://bitworks.software/assets/img/2017-10-20/intuitive-paths.png" alt="Materialized paths"></p><p>每个节点存储到根节点的路径。</p><p>获取子树使用like</p><p><code>SELECT * FROM goods_category WHERE path LIKE &#39;1.1%&#39; ORDER BY path</code></p><p>获取父类:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SELECT * FROM goods_category WHERE &#39;1.1.3&#39; LIKE path||&#39;%&#39; ORDER BY path
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>检查后代:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>SELECT CASE 
    WHEN exists(SELECT 1 FROM goods_category AS gc1, goods_category AS gc2
        WHERE gc1.name = &#39;Construction Material/Fixtures&#39; 	
            AND gc2.name = &#39;Cement&#39; 
            AND gc2.path LIKE gc1.path||&#39;%&#39;)
    THEN &#39;true&#39;
    ELSE &#39;false&#39;
END
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>也可以对每个层级使用独立的列，这会消除 <code>like</code></p><p>优点: 数据直观，查询方便</p><p>缺点:数据插入移动删除复杂，数据深度受路径存储长度限制</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>只有 <code>Adjacency list</code> 避免了冗余，单查询数据复杂，需要递归。</p><p>排序树，物化路径 查询可以避免</p>`,37),r=[d];function n(p,l){return t(),a("div",null,r)}const h=e(i,[["render",n],["__file","treeInRDBMS.html.vue"]]);export{h as default};
