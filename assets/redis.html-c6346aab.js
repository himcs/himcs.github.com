import{_ as l,M as d,p as a,q as s,R as e,t as r,N as n,a1 as i}from"./framework-fa6fd9c7.js";const y={},k=i(`<h1 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h1><h2 id="核心概念" tabindex="-1"><a class="header-anchor" href="#核心概念" aria-hidden="true">#</a> 核心概念</h2><p>键值对内存数据库</p><h3 id="key" tabindex="-1"><a class="header-anchor" href="#key" aria-hidden="true">#</a> key</h3><p>相关命令</p><table><thead><tr><th>命令</th><th>简述</th></tr></thead><tbody><tr><td>DEL key</td><td>删除</td></tr><tr><td>DUMP key</td><td>序列化</td></tr><tr><td>EXISTS key</td><td>是否存在</td></tr><tr><td>EXPIRE key seconds</td><td>设置seconds秒后key删除</td></tr><tr><td>EXPIREAT key timestamp</td><td>到时间戳删除key</td></tr><tr><td>PEXPIRE key milliseconds</td><td>设置 key 的过期时间以毫秒计</td></tr><tr><td>PEXPIREAT key milliseconds-timestamp</td><td>到毫秒时间戳删除key</td></tr><tr><td>KEYS pattern</td><td>查找key，可以使用<code>*</code>通配符</td></tr><tr><td>MOVE key db</td><td>将当前数据库的 key 移动到给定的数据库 db 当中。</td></tr><tr><td>PERSIST key</td><td>移除 key 的过期时间，key 将持久保持。</td></tr><tr><td>PTTL key</td><td>key剩余过期毫秒</td></tr><tr><td>TTL key</td><td>key剩余过期秒</td></tr><tr><td>RANDOMKEY</td><td>从当前数据库中随机返回一个 key 。</td></tr><tr><td>RENAME key newkey</td><td>重命名</td></tr><tr><td>SCAN cursor [MATCH pattern] [COUNT count]</td><td>迭代键</td></tr><tr><td>TYPE key</td><td>返回key类型</td></tr></tbody></table><h2 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型" aria-hidden="true">#</a> 数据类型</h2><p>string, hash, list, set, zset</p><h3 id="string" tabindex="-1"><a class="header-anchor" href="#string" aria-hidden="true">#</a> string</h3><p>存取</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SET test_key <span class="token string">&quot;test_val&quot;</span>
GET test_key
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>api 参考</p><ul><li>SET key value 设置 kv</li><li>GET key 获取k</li><li>GETRANGE key start end 获取key中子串</li><li>GETSET key value 将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</li><li>GETBIT KEY_NAME OFFSET 字符串值指定偏移量上的位(bit)</li><li>MGET key1 [key2..] 获取所有(一个或多个)给定 key 的值。</li><li>SETBIT key offset value 对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)。</li><li>SETEX key seconds value 设置带过期时间的key</li><li>SETNX key value 只有在 key 不存在时设置 key 的值。</li><li>SETRANGE key offset value 用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始。、</li><li>STRLEN key 长度</li><li>MSET key value [key value ...] 同时设置一个或多个 key-value 对</li><li>PSETEX key milliseconds value 这但它以毫秒为单位设置 key 的生存时间</li><li>INCR key 存储的数字+1</li><li>INCRBY key increment 存储值+指定值</li><li>INCRBYFLOAT key increment 将 key 所储存的值加上给定的浮点增量值（increment） 。</li><li>DECR key 存储的数字-1</li><li>DECRBY key decrement 存储的数字-decrement</li><li>APPEND key value 末尾添加</li></ul>`,13),o={href:"https://www.runoob.com/redis/redis-keys.html",target:"_blank",rel:"noopener noreferrer"},c=i(`<h3 id="hash" tabindex="-1"><a class="header-anchor" href="#hash" aria-hidden="true">#</a> hash</h3><p>键值对集合</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>HSET test_hash key1 val1
HGET test_hash key1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>HSET</code>可以设置多个键值对。</p><ul><li>HSET test_hash key1 val1 将哈希表 key 中的字段 field 的值设为 value</li><li>MSET key field1 value1 [field2 value2 ] 同时将多个 field-value (域-值)对设置到哈希表 key 中。</li><li>HSETNX key field value 只有在字段 field 不存在时，设置哈希表字段的值。</li><li>HGET key field 获取存储在哈希表中指定字段的值</li><li>HMGET key field1 [field2] 获取所有给定字段的值</li><li>HGETALL key 获取在哈希表中指定 key 的所有字段和值</li><li>HDEL key field1 [field2] 删除一个或多个哈希表字段</li><li>HEXISTS key field 查看哈希表 key 中，指定的字段是否存在。</li><li>HINCRBY key field increment 为哈希表 key 中的指定字段的整数值加上增量 increment 。</li><li>HINCRBYFLOAT key field increment 为哈希表 key 中的指定字段的浮点数值加上增量 increment</li><li>HKEYS key 获取所有哈希表中的字段</li><li>HVALS key 获取哈希表中所有值。</li><li>HLEN key 获取哈希表中字段的数量</li><li>HSCAN key cursor [MATCH pattern] [COUNT count] 迭代哈希表中的键值对</li></ul><h3 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> list</h3><p>列表 可以左插或右插 一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>lpush test_list k1
rpush test_list k2
lrange test_list 0 10
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>lrange</code>获取</p><ul><li>LPUSH key value1 [value2] 将一个或多个值插入到列表头部</li><li>RPUSH key value1 [value2] 将一个或多个值插入到列表尾部</li><li>LPUSHX key value 将一个或多个值插入到已存在的列表头部</li><li>RPUSHX key value 为已存在的列表添加值</li><li>LRANGE key start stop 获取指定范围元素 可以使用负值 -1代表最后一个元素</li><li>LINSERT key BEFORE|AFTER pivot value 在列表的元素前或者后插入元素</li><li>LLEN key 列表长度</li><li>LPOP key 移出并获取列表的第一个元素</li><li>RPOP key 移出并获取列表的第一个元素</li><li>LREM key count value 移除列表元素 count = 0 为所有，其他情况为绝对值</li><li>LINDEX key index 通过索引获取列表中的元素</li><li>LSET key index value 通过索引设置值</li><li>LTRIM key start stop 保留指定区间元素</li><li>BLPOP key1 [key2 ] timeout 移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li><li>BRPOP key1 [key2 ] timeout 弹出最后一个元素 同上</li><li>BRPOPLPUSH source destination timeout 从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</li><li>RPOPLPUSH source destination 移除列表的最后一个元素，并将该元素添加到另一个列表并返回</li></ul><h3 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> set</h3><p><code>set</code> 是 不含重复元素的无序集合，通过哈希实现。 复杂度为<code>O(1)</code> 集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>sadd test_set key1 val1
smembers test_set
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>SADD key member1 [member2] 向set添加元素</li><li>SMEMBERS key 返回set所有元素</li><li>SREM key member1 [member2] 移除集合中一个或多个成员</li><li>SCRAD key 获取元素数量</li><li>SDIFFSTORE destination key1 [key2] 获取<code>set</code>的差集并存储到<code>destination</code>中</li><li>SINTER key1 [key2] 返回给定所有集合的交集</li><li>SUNION key1 [key2] 返回所有给定集合的并集</li><li>SINTERSTORE destination key1 [key2] 给定集合的交集存储到<code>destination</code>中</li><li>SUNIONSTORE destination key1 [key2] 所有给定集合的并集存储在 destination 集合中</li><li>SISMEMBER key member 判断<code>member</code>是否是<code>key</code>的成员</li><li>SPOP key 移除并返回集合中的一个随机元素</li><li>SRANDMEMBER key [count] 随机返回集合中 一个或多个</li><li>SMOVE source destination member 将 member 元素从 source 集合移动到 destination 集合</li><li>SSCAN key cursor [MATCH pattern] [COUNT count] 迭代集合中的元素</li></ul><p>###　zset</p><p>有排序的<code>zset</code>，每个元素关联一个<code>double</code>类型的分数</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>zadd test_zset 100 key1
zadd test_zset 90 key2
ZRANGEBYSCORE test_zset 0 100
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>ZADD key score1 member1 [score2 member2] 向zset添加元素 或替换已有元素的分数</li><li>ZRANGE key start stop [WITHSCORES] 通过索引区间返回有序集合指定区间内的成员</li><li>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员</li><li>ZRANGEBYLEX key min max [LIMIT offset count] 通过字典区间返回有序集合的成员</li><li>ZCARD key 获取有序集合的成员数</li><li>ZCOUNT key min max 计算在有序集合中指定区间分数的成员数</li><li>ZINCRBY key increment member 有序集合中对指定成员的分数加上增量 incremen</li><li>ZRANK key member 返回有序集合中指定成员的索引</li><li>ZLEXCOUNT key min max 在有序集合中计算指定字典区间内成员数量</li><li>ZREM key member [member ...] 移除有序集合中的一个或多个成员</li><li>ZREMRANGEBYLEX key min max 移除有序集合中给定的字典区间的所有成员</li><li>ZREMRANGEBYRANK key start stop 移除有序集合中给定的排名区间的所有成员 下标</li><li>ZREMRANGEBYSCORE key min max 根据分数移除</li><li>ZREVRANGE key start stop [WITHSCORES] 返回有序集中指定区间内的成员，通过索引，分数从高到低</li><li>ZREVRANGEBYSCORE key max min [WITHSCORES] 返回有序集中指定分数区间内的成员，分数从高到低排序</li><li>ZREVRANK key member 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</li><li>ZSCORE key member 返回有序集中，成员的分数值</li><li>ZINTERSTORE destination numkeys key [key ...] 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</li><li>ZUNIONSTORE destination numkeys key [key ...] 计算给定的一个或多个有序集的并集，并存储在新的 key 中</li><li>ZSCAN key cursor [MATCH pattern] [COUNT count] 迭代有序集合中的元素（包括元素成员和元素分值）</li></ul><h3 id="hyperloglog" tabindex="-1"><a class="header-anchor" href="#hyperloglog" aria-hidden="true">#</a> HyperLogLog</h3><p>不精确的<code>SET</code></p><p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。 但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素</p><p>序号 命令及描述 1 PFADD key element [element ...] 添加指定元素到 HyperLogLog 中。 2 PFCOUNT key [key ...] 返回给定 HyperLogLog 的基数估算值。 3 PFMERGE destkey sourcekey [sourcekey ...] 将多个 HyperLogLog 合并为一个 HyperLogLog</p>`,22);function u(E,m){const t=d("ExternalLinkIcon");return a(),s("div",null,[k,e("p",null,[e("a",o,[r("菜鸟Redis教程"),n(t)])]),c])}const v=l(y,[["render",u],["__file","redis.html.vue"]]);export{v as default};
