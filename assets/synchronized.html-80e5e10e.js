import{_ as n,p as s,q as a,a1 as t}from"./framework-fa6fd9c7.js";const e={},o=t(`<h1 id="synchronized与锁" tabindex="-1"><a class="header-anchor" href="#synchronized与锁" aria-hidden="true">#</a> synchronized与锁</h1><p>Java 中的锁都是基于对象的，每一个对象都可以作为一个锁。</p><h2 id="synchronized-关键字" tabindex="-1"><a class="header-anchor" href="#synchronized-关键字" aria-hidden="true">#</a> synchronized 关键字</h2><p>我们可以使用 <code>synchronized</code> 为一段代码或一个方法加上锁。静态方法上加的是类锁。</p><p>主要有以下形式。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 关键字在实例方法上，锁为当前实例</span>
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">instanceLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// code</span>
<span class="token punctuation">}</span>

<span class="token comment">// 关键字在静态方法上，锁为当前Class对象</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">classLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// code</span>
<span class="token punctuation">}</span>

<span class="token comment">// 关键字在代码块上，锁为括号里面的对象</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">blockLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// code</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>临界区内的代码同一时间只能由一个获得锁的线程执行。</p><p><code>synchronized</code> 下面写法是等价的。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 关键字在实例方法上，锁为当前实例</span>
<span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">instanceLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// code</span>
<span class="token punctuation">}</span>

<span class="token comment">// 关键字在代码块上，锁为括号里面的对象</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">blockLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// code</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>静态方法同理，使用的类锁（class对象）</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token comment">// 关键字在静态方法上，锁为当前Class对象</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">classLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// code</span>
<span class="token punctuation">}</span>

<span class="token comment">// 关键字在代码块上，锁为括号里面的对象</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">blockLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// code</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="锁分类" tabindex="-1"><a class="header-anchor" href="#锁分类" aria-hidden="true">#</a> 锁分类</h2><p>Java6 为了减少获得锁和释放锁带来的性能损耗，引入了 偏向锁 和 轻量锁。Java6 以前，所有的锁都是重量级锁。Java6 后，一个对象有四种锁状态，由低到高分别为：</p><ul><li>无锁</li><li>偏向锁</li><li>轻量锁</li><li>重量锁</li></ul><p>无锁是没有对资源进行锁定，任何线程都可以尝试修改它。</p><p>几种锁会随着竞争逐渐升级，锁容易升级，但降锁条件比较苛刻。锁降级发生在 <code>Stop The World</code> 期间，当 JVM 进入安全点时，会检查是否有闲置的锁，然后进行降级。</p><h3 id="java-对象头" tabindex="-1"><a class="header-anchor" href="#java-对象头" aria-hidden="true">#</a> Java 对象头</h3><p>Java 的锁都是基于对象的，我们看一下 对象的 锁 信息放在哪。</p><p>每个 Java 对象都有对象头。如果是非数组类型，用2个字宽存储对象头，如果是数组，3个字宽存储对象头。</p><p>在32位处理器中，一个字宽是32位；在64位虚拟机中，一个字宽是64位。</p><table><thead><tr><th>长度</th><th>内容</th><th>说明</th></tr></thead><tbody><tr><td>32/64 bit</td><td>Mark Word</td><td>对象的hashCode或锁信息</td></tr><tr><td>32/64 bit</td><td>Class Metadata Address</td><td>对象类型数据指针</td></tr><tr><td>32/64 bit</td><td>Array length</td><td>数组长度</td></tr></tbody></table><p>Mark Word的格式</p><table><thead><tr><th>锁</th><th>29/61 bit</th><th>1bit(是否为偏向锁)</th><th>2bit（锁标志）</th></tr></thead><tbody><tr><td>无锁</td><td></td><td>0</td><td>01</td></tr><tr><td>偏向锁</td><td>线程ID</td><td>1</td><td>01</td></tr><tr><td>轻量锁</td><td>指向栈中锁记录的指针</td><td></td><td>00</td></tr><tr><td>重量级锁</td><td>指向互斥量（重量级锁）的指针</td><td></td><td>10</td></tr><tr><td>GC</td><td></td><td></td><td>11</td></tr></tbody></table><ul><li><p>当对象状态为偏向锁时，Mark Word 存储的是偏向的线程ID；</p></li><li><p>为轻量级锁时，<code>Mark Word</code>存储的是指向线程栈中<code>Lock Record</code>的指针;</p></li><li><p>为重量级锁时，<code>Mark Word</code>为指向堆中 monitor 对象的指针</p></li></ul><h3 id="偏向锁" tabindex="-1"><a class="header-anchor" href="#偏向锁" aria-hidden="true">#</a> 偏向锁</h3><p>Hotspot的作者经过以往的研究发现大多数情况下大多数情况下 <strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，于是引入了偏向锁。</p><p>偏向锁会偏向于第一个获得访问锁的线程，如果接下来，该锁没有被其他线程访问，则持有该锁的线程将永远不需要触发同步。</p><p>也就是说，<strong>偏向锁在资源无竞争情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。</strong></p><h4 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理" aria-hidden="true">#</a> 实现原理</h4><p>一个线程在第一次进入同步块时，会在<strong>对象头</strong>和<strong>栈帧</strong>中的锁记录存储锁偏向的<strong>线程ID</strong>,当下次该线程再进入整个同步块，会检查锁的 Mark Word 放的是不是当前线程 ID。</p><p>如果是，表明线程已经获得了锁，线程进入和退出同步块时不需要花费 CAS 操作来加/解锁。</p><p>如果不是，就代表有另一个线程来竞争这个偏向锁。这时会尝试用CAS来替换 Mark Word里的线程ID为新线程的ID，这时有两种情况：</p><ul><li>成功，表示之前的线程不在了，Mark Word 里的线程ID更新为新线程的ID，锁依然为偏向锁。</li><li><strong>失败</strong>，表示之前的线程依然存在，那么暂停之前的线程，设置偏向锁标识为0，并设置锁标志位为00，<strong>升级</strong>为轻量级锁，会按照轻量级锁的方式进行竞争锁。</li></ul><h4 id="撤销偏向锁" tabindex="-1"><a class="header-anchor" href="#撤销偏向锁" aria-hidden="true">#</a> 撤销偏向锁</h4><p>偏向锁升级为轻量锁时，会暂停拥有偏向锁的线程，重置偏向锁标志位。</p><ul><li>在一个安全点停止拥有锁的线程</li><li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和Mark Word，使其变成无锁状态</li><li>唤醒被停止的线程，将当前锁升级成轻量级锁。</li></ul><p>如果应用程序里的锁通常处于竞争态，偏向锁是一种累赘，这时可以把偏向锁概念关闭</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>-XX:UseBiasedLocking=false
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="轻量级锁" tabindex="-1"><a class="header-anchor" href="#轻量级锁" aria-hidden="true">#</a> 轻量级锁</h3><h4 id="加锁" tabindex="-1"><a class="header-anchor" href="#加锁" aria-hidden="true">#</a> 加锁</h4><p>JVM 为每个线程再<strong>当前线程</strong>的<strong>栈帧</strong>中创建用于存储<strong>锁记录</strong>的空间,我们称为 <strong>Displaced Mark Word</strong>。</p><p>如果一个线程<strong>获得锁</strong>时发现是<strong>轻量级锁</strong>，会把锁的 <strong>Mark Word</strong> <strong>复制</strong>到自己的 <strong>Displaced Mark Word</strong>中。</p><p>然后线程尝试 <strong>CAS</strong> 将锁的**<code>Mark Word</code><strong>替换为指向</strong>锁记录指针**。</p><ul><li>如果<strong>成功</strong>，当前线程<strong>获得锁</strong></li><li>如果<strong>失败</strong>，表示<code>Mark Word</code>已经被替换成了其他线程的锁记录，说明与其他线程<strong>竞争</strong>锁，当前线程尝试使用<strong>自旋</strong>获取锁。</li></ul><blockquote><p>自旋：不断尝试获取锁，一般使用循环实现</p></blockquote><p><strong>自旋</strong>消耗<strong>CPU</strong>资源，如果一直获取不到，线程一直处在自旋状态，白白浪费CPU。JDK采取的方式，适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p><p>当自旋到一定程度，依然没有获取倒锁，即自旋失败了，这个线程会被<strong>阻塞</strong>，同时这个锁会升级为<strong>重量级锁</strong>。</p><h4 id="释放" tabindex="-1"><a class="header-anchor" href="#释放" aria-hidden="true">#</a> 释放</h4><p>释放锁时，当前线程会使用 CAS 将<strong>Displaced Mark Word</strong>的内容复制回锁的<code>Mark Word</code>里，如果无竞争，那么复制会成功。如果有其他线程因为多次自旋导致锁升级为重量级锁，CAS会失败，此时锁被释放并唤醒被阻塞的线程。</p><h3 id="重量级锁" tabindex="-1"><a class="header-anchor" href="#重量级锁" aria-hidden="true">#</a> 重量级锁</h3><p>重量级锁依赖于操作系统的互斥量（mutex） 实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗CPU。</p><p>当多个线程同时请求某个对象锁时，对象锁会设置几种状态来区分请求线程：</p><ul><li>Contention List：请求锁的线程首先放到此竞争队列</li><li>Entry List：Contention List 中那些有资格成为候选人的线程被移到 Entry List</li><li>Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set</li><li>OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck</li><li>Owner：获得锁的线程称为Owner</li><li>!Owner：释放锁的线程</li></ul><p><img src="https://images2015.cnblogs.com/blog/899685/201610/899685-20161024185343875-1509540859.gif" alt=""></p><p>当线程尝试获取锁时，如果锁被占用，该线程会被封装成 <code>ObjectWaiter</code> 对象插入到 Contention List 队尾，然后调用 park 挂起当前线程。</p><p>线程释放锁时，会从 Contention List 或 Entry List 中挑选一个线程唤醒, 被选中的线程叫做 <code>Heir presumptive</code>即假定继承人，但 <code>synchronized</code> 是非公平的，假定继承人不一定能获取到锁。因为对于重量级锁，线程先尝试自旋获取锁，这样会减少操作系统同步操作带来的开销。如果自旋不成功再进入等待队列。</p><p>如果线程获得锁后调用 <code>Object.wait</code> 方法，则会将线程加入到 <code>Wait Set</code> 中，当被 <code>Object.notify</code> 唤醒后，会将线程从 <code>Wait Set</code> 移动到<code>Contention List</code>或 <code>Entry List</code>中。</p><p>当调用一个锁对象的 <code>wait</code> 或 <code>notify</code>时，如果锁时偏向锁或轻量锁则先升级为重量锁。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><h3 id="锁升级流程" tabindex="-1"><a class="header-anchor" href="#锁升级流程" aria-hidden="true">#</a> 锁升级流程</h3><ol><li><p>偏向锁 -&gt; 轻量级锁</p><ul><li><p>线程检查 markword 锁标记，如果是偏向锁，并且 锁对象的线程ID为自己，获取锁</p></li><li><p>如果不是自己，执行CAS 替换操作，替换失败，说明有其他线程竞争锁，此时锁升级为轻量级锁，暂停获得锁的线程</p></li></ul></li><li><p>轻量级锁 -&gt; 重量级锁</p></li></ol><ul><li>线程将锁对象的 markword复制到自己线程栈的所记录</li><li>CAS 替换锁对象的 markdord 为当前线程栈的地址</li><li>替换成功说明获取到锁</li><li>替换失败，自旋一段时间，如果还是未获取到，升级为重量级锁，自旋线程进入阻塞，等待被唤醒。</li></ul><h3 id="锁对比" tabindex="-1"><a class="header-anchor" href="#锁对比" aria-hidden="true">#</a> 锁对比</h3><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td><td>适用于只有一个线程访问同步块场景。</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞，提高了程序的响应速度。</td><td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td><td>追求响应时间。同步块执行速度非常快。</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不会消耗CPU。</td><td>线程阻塞，响应时间缓慢。</td><td>追求吞吐量。同步块执行时间较长。</td></tr></tbody></table>`,64),d=[o];function i(c,p){return s(),a("div",null,d)}const r=n(e,[["render",i],["__file","synchronized.html.vue"]]);export{r as default};
