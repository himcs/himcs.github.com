import{_ as e,p as a,q as i,a1 as c}from"./framework-fa6fd9c7.js";const d="/assets/image-20201218110508561-087fc299.png",l="/assets/image-20201218110544459-6078eb0a.png",o="/assets/image-20201218111511810-7a418d72.png",r="/assets/image-20201218111613497-364a71ab.png",t="/assets/image-20201218111634707-81796aa3.png",n={},s=c('<h1 id="cap定理" tabindex="-1"><a class="header-anchor" href="#cap定理" aria-hidden="true">#</a> CAP定理</h1><h2 id="什么是cap定理" tabindex="-1"><a class="header-anchor" href="#什么是cap定理" aria-hidden="true">#</a> 什么是CAP定理</h2><ul><li>Consistency 一致性</li><li>Availability 可用性</li><li>Partition tolerance 分区容忍度</li></ul><h3 id="c" tabindex="-1"><a class="header-anchor" href="#c" aria-hidden="true">#</a> C</h3><p>服务期间数据一致性</p><h3 id="a" tabindex="-1"><a class="header-anchor" href="#a" aria-hidden="true">#</a> A</h3><p>服务节点收到请求，在合理时间做出相应</p><h3 id="p" tabindex="-1"><a class="header-anchor" href="#p" aria-hidden="true">#</a> P</h3><p>分区容忍度，当通信出现故障，仍能正常提供服务 一致性 C 需要锁定资源惊醒同步 可用性 A 要求合理事件做出相应 C和A是互斥的</p><h2 id="cap-难题" tabindex="-1"><a class="header-anchor" href="#cap-难题" aria-hidden="true">#</a> CAP 难题</h2><ul><li>容错性P无法避免，分布式系统通常 A &gt; C</li><li>PA满足，比如导致一致性难题</li><li>分布式系统不可能100%保证一致性，都是尽可能保证成功率</li><li>分布式事务是解决一致性的一种解决方案，通常是 &quot;保证最终一致性&quot;</li></ul><h3 id="一致性分类" tabindex="-1"><a class="header-anchor" href="#一致性分类" aria-hidden="true">#</a> 一致性分类</h3><ul><li>强一致性： 数据必须完全一致，中间过程不可见，同步完成</li><li>弱一致性： 运行部分一致性，中间过程可见，异步完成</li><li>最终一致性： 过一段事件后，保证数据完全一致</li></ul><h2 id="xa-与-jta" tabindex="-1"><a class="header-anchor" href="#xa-与-jta" aria-hidden="true">#</a> XA 与 JTA</h2><p><code>JTA</code> 依托与 <code>J2EE</code>容器</p><p>第一阶段 创建事务不提交</p><p><img src="'+d+'" alt="image-20201218110508561"></p><p>第二阶段 提交。如果一阶段有服务超时或失败，就会对所有服务进行回滚</p><p><img src="'+l+'" alt="image-20201218110544459"></p><ul><li><code>XA</code> 是 X/Open 组织提出的分布式事务规范、</li><li><code>XA</code> 采用两阶段方案(<code>Pre</code>, <code>Commit</code>)</li><li><code>JTA(Java Transaction API</code>)<code>J2EE</code>模块，定义<code>Java</code>的<code>XA</code>接口</li><li><code>J2EE</code> 容器(<code>Weblogic</code>,<code>JBoss</code>) 是<code>JTA</code>的实现</li></ul><h3 id="jta问题" tabindex="-1"><a class="header-anchor" href="#jta问题" aria-hidden="true">#</a> JTA问题</h3><ul><li>同步阻塞，并发效率差</li><li>分布式架构存在瓶颈</li><li>脑裂，无法保证数据一致性(提交阶段，J2EE 容器无法知道微服务是否提交成功)</li><li>数据源类型受限</li></ul><h2 id="tcc" tabindex="-1"><a class="header-anchor" href="#tcc" aria-hidden="true">#</a> TCC</h2><ul><li>TCC 是 Try（尝试），Confirm（确认）， Cancel（取消）</li><li>Try 尝试阶段，对资源进行<strong>锁定</strong></li><li>Confirm 确认阶段，对资源进行确认，完成操作</li><li>Cancel 取消阶段，对资源进行还原，取消操作</li></ul><p>尝试</p><p><img src="'+o+'" alt="image-20201218111511810"></p><p>确认</p><p><img src="'+r+'" alt="image-20201218111613497"></p><p>取消</p><p><img src="'+t+'" alt="image-20201218111634707"></p><p>如何保证最终一致性</p><ul><li>TCC认为<code>Confirm</code>和<code>Cancel</code>一定成功</li><li><code>Confrim</code>和<code>Cacel</code>尽可能不要产生服务通信</li><li><code>Confrim</code>和<code>Cancel</code>如果失败,<code>TCC</code>框架进行重试补偿</li><li>C/C彻底失败，需要定时任务检查或人工介入</li></ul>',32),h=[s];function p(m,u){return a(),i("div",null,h)}const _=e(n,[["render",p],["__file","CAP定理.html.vue"]]);export{_ as default};
