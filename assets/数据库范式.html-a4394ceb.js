import{_ as t,p as a,q as d,a1 as h}from"./framework-fa6fd9c7.js";const e={},r=h('<h1 id="数据库范式" tabindex="-1"><a class="header-anchor" href="#数据库范式" aria-hidden="true">#</a> 数据库范式</h1><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介" aria-hidden="true">#</a> 简介</h2><p>源自英文 Normal Form，简称NF。</p><p>不同的范式对关系约束不同，越高的NF数据库冗余越小。</p><p>高等级范式在低级范式基础上更近一步，是低级范式的子集。</p><h2 id="start" tabindex="-1"><a class="header-anchor" href="#start" aria-hidden="true">#</a> Start</h2><p>假如我们有下面的需求：</p><p>存储用户的地址信息，每个用户都只有一个地址</p><p>初始设计</p><table><thead><tr><th>用户</th><th>地址</th></tr></thead><tbody><tr><td>张三</td><td>北京市朝阳区xx街道</td></tr></tbody></table><h2 id="_1nf" tabindex="-1"><a class="header-anchor" href="#_1nf" aria-hidden="true">#</a> 1NF</h2><p>要求每列都是不可再分的数据单元。</p><p>如果业务上要求地址区分省市区街道，那么只有一个地址字段就不满足1NF。将地址拆分为多个字段满足1NF。</p><p>原始设计，不满足1NF，拆分地址字段后满足1NF</p><table><thead><tr><th>用户</th><th>省</th><th>市</th><th>区</th><th>街道</th></tr></thead><tbody><tr><td>张三</td><td>北京</td><td>北京</td><td>朝阳区</td><td>xx街道</td></tr></tbody></table><h2 id="_2nf" tabindex="-1"><a class="header-anchor" href="#_2nf" aria-hidden="true">#</a> 2NF</h2><p>2NF要求数据的每列都要与主键有关。</p><p>加入主键字段（id) 后满足2NF,可以区分同名同地址的用户了。</p><table><thead><tr><th>id</th><th>用户</th><th>省</th><th>市</th><th>区</th><th>街道</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>北京</td><td>北京</td><td>朝阳区</td><td>xx街道</td></tr></tbody></table><h2 id="_3nf" tabindex="-1"><a class="header-anchor" href="#_3nf" aria-hidden="true">#</a> 3NF</h2><p>3NF要求每列数据与主键直接相关。</p><p>例如 有部门表和员工表，员工表只能存储部门表的id，不能冗余部门表的其他字段（名称。等）。</p><h2 id="bcnf" tabindex="-1"><a class="header-anchor" href="#bcnf" aria-hidden="true">#</a> BCNF</h2><p>防止主键的某一列依赖主键的其他列。单列主键不存在这个问题。</p><h2 id="反范式" tabindex="-1"><a class="header-anchor" href="#反范式" aria-hidden="true">#</a> 反范式</h2><p>适当的冗余字段，可以减少join操作，提高查询性能，但会提高数据维护成本。</p>',26),n=[r];function i(p,c){return a(),d("div",null,n)}const s=t(e,[["render",i],["__file","数据库范式.html.vue"]]);export{s as default};
