import{_ as a,p as n,q as s,a1 as e}from"./framework-fa6fd9c7.js";const t={},c=e(`<h1 id="io" tabindex="-1"><a class="header-anchor" href="#io" aria-hidden="true">#</a> IO</h1><h2 id="输入和输出" tabindex="-1"><a class="header-anchor" href="#输入和输出" aria-hidden="true">#</a> 输入和输出</h2><p><code>Java API</code>中，可从中读入一个字节序列的对象叫<strong>输入流</strong>，可以写入一个直接对象成为<strong>输出流</strong>;</p><p>抽象类<code>InputStream</code>和<code>OutputStream</code>是<code>I/O</code>包的基础。</p><p>因为面向字节的流不便于处理<code>Unicode</code>编码信息，抽象出来<code>Reader</code>和<code>Writer</code>专门处理，衍生类的读去和写入操作都是基于两个字节的<code>Char</code>值的。</p><h3 id="inputstream" tabindex="-1"><a class="header-anchor" href="#inputstream" aria-hidden="true">#</a> InputStream</h3><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;">内容</th></tr></thead><tbody><tr><td style="text-align:left;"><code>int read() throws IOException;</code></td><td style="text-align:left;">读取并返回一个字节，结束返回<code>-1</code></td></tr><tr><td style="text-align:left;"><code>int available() throws IOException;</code></td><td style="text-align:left;">返回可读入的字节数量</td></tr></tbody></table><p><code>read</code>其他方法都基于<code>read()</code>实现</p><h3 id="outputstream" tabindex="-1"><a class="header-anchor" href="#outputstream" aria-hidden="true">#</a> OutputStream</h3><table><thead><tr><th style="text-align:left;">操作</th><th style="text-align:left;">内容</th></tr></thead><tbody><tr><td style="text-align:left;"><code>int write(int b) throws IOException;</code></td><td style="text-align:left;">写入一个字节</td></tr></tbody></table><p><code>write</code>其他方法都基于<code>write(int b)</code>实现</p><h3 id="阻塞" tabindex="-1"><a class="header-anchor" href="#阻塞" aria-hidden="true">#</a> 阻塞</h3><p><code>read</code>和<code>write</code>在执行时都将阻塞，直到字节确实被读入或写出。这意味着等待过程=线程阻塞。当完成操作后，应当调用<code>close</code>关闭<code>I/O</code>流。 对于任何<code>Closeable</code>接口可以使用<code>try-with-resouce</code>进行自动关闭操作.</p><h3 id="结合-输入-输出流" tabindex="-1"><a class="header-anchor" href="#结合-输入-输出流" aria-hidden="true">#</a> 结合 输入/输出流</h3><p>文件流<code>File{Input|Output}Stream</code>提供了对磁盘文件的文件流。</p><blockquote><p>java.io 中的类相对路径的解释以用户工作目录开始,通过<code>System.getProperty(&quot;user.dir&quot;)</code>查看</p></blockquote><p><code>Java</code>中的流可以嵌套使用,即继承之<code>FilterInputStream/FilterOutputStream</code>的类可用于向处理字节的流添加额外的功能。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token class-name">Path</span> p <span class="token operator">=</span> <span class="token class-name">Paths</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">getProperty</span><span class="token punctuation">(</span><span class="token string">&quot;user.dir&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;resources&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;1.txt&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">InputStream</span> inputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">toFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">BufferedInputStream</span> bufferedInputStream <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span>inputStream<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="文本流" tabindex="-1"><a class="header-anchor" href="#文本流" aria-hidden="true">#</a> 文本流</h2><p><code>Java</code>内部使用<code>UTF-16</code>编码，即一个字符使用16位（2个字节）保存，字符串“1234”编码为(0031 0032 0033 0034).</p><p><code>OutputStreamWriter</code>将输出流转换为字节流,<code>InputStreamReader</code>将字节流转换位<code>Java</code>可以理解的字符。</p><p>例如 从键盘获取一行输入</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">IOException</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">(</span>
                <span class="token class-name">BufferedReader</span> in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">InputStreamReader</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token class-name">String</span> s <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="写文本" tabindex="-1"><a class="header-anchor" href="#写文本" aria-hidden="true">#</a> 写文本</h3><p>文本输出，可使用<code>PrintWriter</code>对象，使用<code>print</code>,<code>println</code>和<code>printf</code>方法输出。</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>        <span class="token keyword">try</span> <span class="token punctuation">(</span><span class="token class-name">PrintWriter</span> out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PrintWriter</span><span class="token punctuation">(</span><span class="token string">&quot;1.txt&quot;</span><span class="token punctuation">,</span> <span class="token class-name">StandardCharsets</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">&quot;hello world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="读文本" tabindex="-1"><a class="header-anchor" href="#读文本" aria-hidden="true">#</a> 读文本</h3><p>使用<code>Scanner</code>读取文本输入，可以从<code>InputStream</code>构建,</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token class-name">Scanner</span> scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>早期<code>Java</code>版本，只能通过<code>BufferedReader</code>的<code>readLine</code>获取下一行文本。</p><p><code>BufferedReader</code>加入了一个<code>lines</code>方法，可以产生一个<code>Stream&lt;String&gt;</code>数组.</p><p><code>Scanner</code>可以读取非字符串类型，而<code>BufferedReader</code>当前版本不可以。</p><h2 id="文件api" tabindex="-1"><a class="header-anchor" href="#文件api" aria-hidden="true">#</a> 文件API</h2><h3 id="path" tabindex="-1"><a class="header-anchor" href="#path" aria-hidden="true">#</a> Path</h3><h4 id="获取" tabindex="-1"><a class="header-anchor" href="#获取" aria-hidden="true">#</a> 获取</h4><p><code>Path</code>表示一个路径,</p><p>通过静态方法<code>Paths.get(String first, String... more)</code>获取路径</p><blockquote><p>路径不必对于某个实际存在的文件,它只是一个抽象的名称序列.</p></blockquote><h4 id="相对路解析" tabindex="-1"><a class="header-anchor" href="#相对路解析" aria-hidden="true">#</a> 相对路解析</h4><p>获取<code>Path</code>对象后,可调用<code>resolve</code>获得相对路径. <code>resolveSibling</code>得到同级兄弟目录</p><p><code>resolve</code>的反向操作时<code>relative</code> 例如在<code>/home/fred/myprog</code>对<code>/home/cay</code>调用<code>relative</code>会产生<code>../fred/myprog</code></p><p><code>normalize</code>删除冗余的<code>.</code>和<code>..</code></p><p><code>toAbsoultPath</code>产生绝对路径</p><p><code>getRoot</code> 根路径 <code>/</code> <code>D:\\</code><code>getFileName</code> 文件(夹)名 <code>getParent()</code> 父路径 <code>toFile</code> 获得<code>File</code>对象</p><p>通过<code>File</code>对象的<code>toPath</code>可以获得<code>Path</code>对象</p><h3 id="files" tabindex="-1"><a class="header-anchor" href="#files" aria-hidden="true">#</a> Files</h3><h4 id="读写文件" tabindex="-1"><a class="header-anchor" href="#读写文件" aria-hidden="true">#</a> 读写文件</h4><p><code>Files.readAllBytes</code>读取一个文件的所有字节内容 <code>List&lt;String&gt; readAllLines</code> 获得所有行 <code>newInputStream/newOutputStream/newBufferedReader/newBufferedWriter</code> 从路径获得指定流 <code>Files.write</code>向指定路径写入字节</p><h4 id="文件-目录创建" tabindex="-1"><a class="header-anchor" href="#文件-目录创建" aria-hidden="true">#</a> 文件/目录创建</h4><p><code>createDirectory</code> 创建单个目录（要求目录前置目录以存在） <code>createDirectories</code> 创建目录（自动创建中间目录） <code>createFile</code> 创建文件（如果文件已存在，调用抛出异常, 检测和创建时原子操作） 临时文件创建 <code>createTempDirectory/createTempFile</code></p><h3 id="复制-移动-删除" tabindex="-1"><a class="header-anchor" href="#复制-移动-删除" aria-hidden="true">#</a> 复制/移动/删除</h3><p><code>File.copy</code>复制 <code>File.move</code>移动 （覆盖使用 REPLACE_EXISTING, 复制文件属性 使用COPY_ATTRIBUTES)</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> f<span class="token punctuation">.</span><span class="token function">resolveSibling</span><span class="token punctuation">(</span><span class="token string">&quot;test.txt.cpy&quot;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">StandardCopyOption</span><span class="token punctuation">.</span><span class="token constant">REPLACE_EXISTING</span><span class="token punctuation">,</span> <span class="token class-name">StandardCopyOption</span><span class="token punctuation">.</span><span class="token constant">COPY_ATTRIBUTES</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><code>File.delete(path)</code> 删除（如果文件不存在，会抛出异常） <code>File.deleteIfExists</code> 如果存在才删除</p><h3 id="获取文件信息" tabindex="-1"><a class="header-anchor" href="#获取文件信息" aria-hidden="true">#</a> 获取文件信息</h3><h4 id="检测文件属性" tabindex="-1"><a class="header-anchor" href="#检测文件属性" aria-hidden="true">#</a> 检测文件属性</h4><p><code>exists</code> 存在 <code>notExists</code>不存在 <code>isReadable</code><code>isWritable</code><code>isExecutable</code><code>isSymbolicLink</code> 链接文件 <code>isDirectory</code><code>isRegularFile</code> 常规文件</p><p><code>size</code> 文件字节数 <code>getOwner</code>文件所有者</p><p><code>readAttributes</code>读取封装信息 例如获取基础属性</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code>        <span class="token class-name">BasicFileAttributes</span> attributes <span class="token operator">=</span>   <span class="token class-name">Files</span><span class="token punctuation">.</span><span class="token function">readAttributes</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token class-name">BasicFileAttributes</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>attributes<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><code>BasicFileAttributes</code>封装了<code>lastModifiedTime</code>等信息</p><h3 id="目录检索" tabindex="-1"><a class="header-anchor" href="#目录检索" aria-hidden="true">#</a> 目录检索</h3><p><code>Stream&lt;Path&gt;list(Path dir)</code> 返回一个路径流，目录读取是惰性的 <code>list</code>不会进入子目录 <code>Stream&lt;Path&gt; walk</code>可对目录中所有子目录进行检索（深度优先），可以指定深度。</p><h4 id="目录流" tabindex="-1"><a class="header-anchor" href="#目录流" aria-hidden="true">#</a> 目录流</h4><p><code>newDirectoryStream</code>可以产生一个目录流,它是专门用于遍历目录的接口,可以使用增强for循环.</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DirectoryStream</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>
    <span class="token keyword">extends</span> <span class="token class-name">Closeable</span><span class="token punctuation">,</span> <span class="token class-name">Iterable</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个方法可以使用<code>glob</code>来过滤文件，例如只要<code>java</code>结尾的文件</p><p>细粒度的控制</p><p>使用<code>walkFileTree</code>,传入一个<code>FileVisitor</code></p><h5 id="filevisitor" tabindex="-1"><a class="header-anchor" href="#filevisitor" aria-hidden="true">#</a> FileVisitor</h5><p>preVisitDirectory 访问目录前</p><p>visitFile 访问文件</p><p>visitFileFailed 访问文件失败</p><p>postVisitDirectory 访问文件夹后</p><p>方法返回<code>FileVisitResult</code>枚举</p>`,75),o=[c];function p(i,d){return n(),s("div",null,o)}const r=a(t,[["render",p],["__file","IO.html.vue"]]);export{r as default};
