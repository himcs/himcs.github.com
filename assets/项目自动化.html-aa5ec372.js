import{_ as r,M as s,p as l,q as t,R as e,t as a,N as n,a1 as d}from"./framework-fa6fd9c7.js";const c={},o=e("h1",{id:"项目自动化",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#项目自动化","aria-hidden":"true"},"#"),a(" 项目自动化")],-1),u=e("h2",{id:"gradle",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#gradle","aria-hidden":"true"},"#"),a(" Gradle")],-1),v=e("ul",null,[e("li",null,[e("p",null,"build.gradle 它是 Gradle 的配置文件."),e("p",null,"build.gradle 本质是是一个 Groovy 脚本， 其中配置就是 Groovy 代码")]),e("li",null,[e("p",null,"settings.gradle 也是一个 Gradle 配置文件,用来支持多模块。"),e("p",null,"整个项目只有一个 settings.gradle , 每个模块都可以有一个 build.gradle")])],-1),p={href:"https://github.com/himcs/zero",target:"_blank",rel:"noopener noreferrer"},h=d(`<p>首先运行 <code>./gradlew idea</code> 生成IDEA 工程，导入IDEA。</p><p>这里有两点需要说明一下。</p><p>第一，这里用的 gradlew，它是 Gradle 命令的一个封装，它会自动下载一个构建这个项目所需的 Gradle，重点是通过这个命令锁定了 Gradle 的版本，避免因为构建脚本的差异，造成“你成功我失败”的情况。</p><p>第二，IDE 的工程是由 Gradle 生成的。很多人会凭借直觉，用 IDE 直接打开。有一些团队的项目里有好多个构建文件，究竟用哪个打开，不去问人是根本不知道的，这对项目的新人是非常不友好的。生成的做法与前面 Gradle 封装是类似的，它可以避免因为本地安装不同版本 IDE 造成各种问题。另外，因为 IDE 的工程是生成的，如果项目里一旦增加了新的程序库依赖，你只需重新执行一次上面的命令就好了，现在的 IDE 都有很好的自动加载能力，当它检测到工程文件的变化，就会重新加载。</p><h3 id="插件配置" tabindex="-1"><a class="header-anchor" href="#插件配置" aria-hidden="true">#</a> 插件配置</h3><p>Gradle 里，许多能力都是插件形式提供的，比如生成 IDEA 工程就是配置文件里的一句话。</p><div class="language-groovy line-numbers-mode" data-ext="groovy"><pre class="language-groovy"><code>apply plugin<span class="token punctuation">:</span> <span class="token string">&#39;idea&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,7),m={href:"https://docs.gradle.org/current/userguide/plugin_reference.html",target:"_blank",rel:"noopener noreferrer"},b=d(`<h3 id="模块配置" tabindex="-1"><a class="header-anchor" href="#模块配置" aria-hidden="true">#</a> 模块配置</h3><p>首先是分模块。处非代码库非常小，否则分模块是一种必然。一种恰当的方式是根据业务划分代码。比如，用户相关的内容放到一个模块里，把交易订单信息放到一个模块里，把物流信息放到另一个模块里。</p><p>如果未来做微服务，每一个模块就可以成为独立的服务。</p><p>模块信息都配置在 settings.gradle 中。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>rootProject.name = &#39;geektime-zero&#39;

include &#39;zero-bootstrap&#39;
include &#39;zero-identity&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="项目依赖配置" tabindex="-1"><a class="header-anchor" href="#项目依赖配置" aria-hidden="true">#</a> 项目依赖配置</h3><p>例如 zero-bootstrap 依赖 zero-identity</p><p>可以在 zero-bootstrap 目录下的 build.gradle加入</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>project.dependencies {
    implementation(project(&#39;:zero-identity&#39;))
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者在项目根目录下 build.gradle 加入</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>configure(subprojects - project(&#39;:zero-bootstrap&#39;)) {
    project(&#39;:zero-bootstrap&#39;).dependencies {
        implementation(project)
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="版本配置" tabindex="-1"><a class="header-anchor" href="#版本配置" aria-hidden="true">#</a> 版本配置</h3><p>版本配置信息放在 gradle.properties</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>guavaVersion=31.1-jre
springBootVersion=2.6.4
lombokVersion=1.18.22
mysqlVersion=8.0.27
junitVersion=5.8.2
assertJVersion=3.22.0
mockitoVersion=4.4.0
flywayVersion=8.5.4
jacocoVersion=0.8.7
checkstyleVersion=9.3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="目录结构" tabindex="-1"><a class="header-anchor" href="#目录结构" aria-hidden="true">#</a> 目录结构</h3><p>代码目录结构，在 Java 世界里已经是一件约定俗成的事情了。</p><p>src/main/java 下放源代码，src/main/resources 下放配置文件，src/test/java 放测试代码。</p><p>这是约定优于配置（Convention over Configuration）思想的体现。</p><h2 id="检查" tabindex="-1"><a class="header-anchor" href="#检查" aria-hidden="true">#</a> 检查</h2><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>./gradlew check
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个检查会检查什么呢？这取决于配置。在这个项目里，我们应用了 Java 插件，它就可以编译 Java 文件，检查代码是否可以正常编译，运行测试，检查代码是否功能正常等等。但我要求更多。</p><h3 id="代码风格检查" tabindex="-1"><a class="header-anchor" href="#代码风格检查" aria-hidden="true">#</a> 代码风格检查</h3><p>最基本的代码风格检查要放在构建脚本里，这里用 CheckStyle 来做这件事。缺省情况下，你只要应用 Checkstyle 插件即可。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>apply plugin: &#39;checkstyle&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="代码覆盖率检查" tabindex="-1"><a class="header-anchor" href="#代码覆盖率检查" aria-hidden="true">#</a> 代码覆盖率检查</h3><p>代码覆盖率检查也要放到构建脚本里，这里用 JaCoCo.</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>apply plugin: &#39;jacoco&#39;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>特别的地方，测试覆盖率固定在100%.</p><h3 id="数据库迁移插件" tabindex="-1"><a class="header-anchor" href="#数据库迁移插件" aria-hidden="true">#</a> 数据库迁移插件</h3><p>使用 flyway.(仅在本地或开发环境使用)</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>plugins {
    id &quot;org.flywaydb.flyway&quot; version &quot;5.2.4&quot;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面先要做一些基本的配置，保证可以连接到数据库。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>
flyway {
    url = &#39;jdbc:mysql://localhost:3306/zero_test?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&#39;
    user = &#39;zero&#39;
    password = &#39;zero_test&#39;
    locations = [&quot;filesystem:$rootDir/gradle/config/migration&quot;]
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那么如何修改数据库呢?先添加一个数据库迁移文件,在示例项目中，我创建一个迁移文件（gradle/config/migration/V2022.06.22.16.28__Create_user_table.sql），在其中创建了一个 User 表。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>CREATE TABLE zero_users(
    id bigint(20) not null AUTO_INCREMENT,
    name varchar(100) not null unique,
    password varchar(100) not null,
    primary key(id)
);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的迁移文件版本，我选择了以时间戳的方式进行命名，还有一种方式是以版本号的方式，比如 V1、V2。时间戳命名方式的好处是，不同的人可以同时开发，命名冲突的几率很小，而采用版本号命名的方式，命名冲突的概率会大一些。</p><p>添加好数据库迁移文件之后，只要执行下面这个命令就好：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>./gradlew flywayMigrate
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样，对数据库的修改就在数据库里了，你可以打开数据库查看一下。</p><h2 id="构建应用" tabindex="-1"><a class="header-anchor" href="#构建应用" aria-hidden="true">#</a> 构建应用</h2><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>./gradlew build
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>会在 zero-bootstrap/build/libs 下生成可执行JAR包。此外build 依赖 check 任务，构建前会先对代码进行检查。</p><p>打包完成，运行应用</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>java -jar zero-bootstrap/build/libs/zero-bootstrap-*-boot.jar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>开发过程中可以用Gradle 命令运行,</p><p>IDEA 中可以找到 Bootstrap 这个类，直接运行。</p><h2 id="总结时刻" tabindex="-1"><a class="header-anchor" href="#总结时刻" aria-hidden="true">#</a> 总结时刻</h2><ul><li>生成IDEA 工程</li><li>编译</li><li>打包</li><li>运行测试</li><li>代码风格检查</li><li>测试覆盖率</li><li>数据库迁移</li><li>运行应用</li></ul><p>这里的自动化是一个最基本的示例。实际上几乎所有重复或繁琐的工作，都应该自动化。</p><p>项目自动化是持续集成的基础，在持续集成服务上执行的命令，就应该是我们在构建脚本中写好的。</p><p>如果今天的内容你只能记住一件事，那请记住：<strong>将你的工作过程自动化</strong>。</p>`,51);function g(x,_){const i=s("ExternalLinkIcon");return l(),t("div",null,[o,u,v,e("p",null,[a("项目地址"),e("a",p,[a("zero"),n(i)])]),h,e("p",null,[a("官方插件文档"),e("a",m,[a("Gradle Plugin Reference"),n(i)])]),b])}const y=r(c,[["render",g],["__file","项目自动化.html.vue"]]);export{y as default};
